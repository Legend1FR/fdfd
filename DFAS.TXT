const { TelegramClient } = require("telegram");
const { StringSession } = require("telegram/sessions");
const fs = require("fs");
const input = require("input");
const http = require("http");
const https = require("https");

const { performance } = require('perf_hooks');
const puppeteer = require('puppeteer');
// قائمة التوكنات المراقبة
const trackedTokens = {};

// متصفح مشترك لجميع التوكنات لتوفير الذاكرة
let sharedBrowser = null;

// حد أقصى لعدد التوكنات المراقبة في نفس الوقت
const MAX_TRACKED_TOKENS = 100;

// ملف حفظ التوكنات المتتبعة
const trackedTokensFile = 'tracked_tokens.json';

// إنشاء المتصفح المشترك
async function getSharedBrowser() {
  if (sharedBrowser && sharedBrowser.isConnected()) {
    return sharedBrowser;
  }

  try {
    console.log('🔄 جاري إنشاء متصفح مشترك جديد...');
    const launchOptions = {
      headless: true, // تغيير إلى false لتجنب اكتشاف البوت
      args: [
        '--no-sandbox', 
        '--disable-setuid-sandbox', 
        '--disable-blink-features=AutomationControlled',
        '--disable-web-security',
        '--disable-dev-shm-usage',
        '--no-first-run',
        '--disable-default-apps',
        '--disable-extensions',
        '--disable-infobars',
        '--disable-features=VizDisplayCompositor',
        '--window-size=1366,768',
        '--start-maximized',
        '--disable-background-timer-throttling',
        '--disable-backgrounding-occluded-windows',
        '--disable-renderer-backgrounding'
      ]
    };

    // تحديد مسارات Chrome المتعددة للـ Windows
    const chromePaths = [
      'C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe',
      'C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe',
      process.env.PROGRAMFILES + '\\Google\\Chrome\\Application\\chrome.exe',
      process.env['PROGRAMFILES(X86)'] + '\\Google\\Chrome\\Application\\chrome.exe',
      process.env.PUPPETEER_EXECUTABLE_PATH
    ].filter(Boolean);

    let browserLaunched = false;
    
    // محاولة استخدام Chrome المثبت على النظام
    for (const chromePath of chromePaths) {
      try {
        if (fs.existsSync(chromePath)) {
          launchOptions.executablePath = chromePath;
          sharedBrowser = await puppeteer.launch(launchOptions);
          browserLaunched = true;
          console.log(`🌐 تم إطلاق المتصفح المشترك الجديد من: ${chromePath}`);
          break;
        }
      } catch (err) {
        console.log(`⚠️ فشل في إطلاق Chrome من ${chromePath}: ${err.message}`);
      }
    }

    // محاولة استخدام Chrome المحمّل بواسطة Puppeteer
    if (!browserLaunched) {
      try {
        delete launchOptions.executablePath;
        sharedBrowser = await puppeteer.launch(launchOptions);
        browserLaunched = true;
        console.log(`🌐 تم إطلاق المتصفح المشترك الجديد بواسطة Puppeteer`);
      } catch (err) {
        console.error(`❌ فشل في إطلاق المتصفح المشترك: ${err.message}`);
        throw err;
      }
    }

    return sharedBrowser;
  } catch (error) {
    console.error('❌ خطأ في إنشاء المتصفح المشترك:', error.message);
    sharedBrowser = null;
    throw error;
  }
}

// إغلاق المتصفح المشترك بأمان
async function closeSharedBrowser() {
  if (sharedBrowser) {
    try {
      console.log('🔄 جاري إغلاق المتصفح المشترك...');
      
      // إغلاق جميع الصفحات أولاً مع مهلة زمنية
      const pages = await Promise.race([
        sharedBrowser.pages(),
        new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout getting pages')), 3000))
      ]);
      
      for (const page of pages) {
        try {
          await Promise.race([
            page.close(),
            new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout closing page')), 2000))
          ]);
        } catch (err) {
          // تجاهل أخطاء إغلاق الصفحات
        }
      }
      
      // إغلاق المتصفح مع مهلة زمنية
      await Promise.race([
        sharedBrowser.close(),
        new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout closing browser')), 5000))
      ]);
      
      console.log('✅ تم إغلاق المتصفح المشترك بنجاح');
      sharedBrowser = null;
    } catch (error) {
      console.error('⚠️ خطأ في إغلاق المتصفح:', error.message);
      // في حالة فشل الإغلاق العادي، استخدم الإنهاء القسري
      try {
        const process = sharedBrowser.process();
        if (process && !process.killed) {
          process.kill('SIGKILL');
          console.log('⚡ تم إنهاء عملية المتصفح قسرياً');
        }
      } catch (killError) {
        console.error('❌ فشل في إنهاء عملية المتصفح:', killError.message);
      }
      sharedBrowser = null;
    }
  }
}

// حفظ التوكنات المتتبعة إلى ملف
function saveTrackedTokens() {
  try {
    const tokensToSave = {};
    Object.keys(trackedTokens).forEach(token => {
      const t = trackedTokens[token];
      tokensToSave[token] = {
        token: t.token,
        startTime: t.startTime,
        firstPrice: t.firstPrice,
        lastPrice: t.lastPrice,
        maxIncrease: t.maxIncrease,
        reached50: t.reached50,
        stopped: t.stopped,
        browserFailed: t.browserFailed,
        manualMode: t.manualMode,
        rugcheckStatus: t.rugcheckStatus, // إضافة حفظ حالة rugcheck
        // إضافة حفظ الخصائص الجديدة
        previousHighPrice: t.previousHighPrice,
        currentHighPrice: t.currentHighPrice,
        lastRiseTime: t.lastRiseTime,
        rapidRiseAchieved: t.rapidRiseAchieved,
        priceRiseHistory: t.priceRiseHistory || [] // تأكد من حفظ المصفوفة
        // لا نحفظ page لأنها كائنات غير قابلة للتسلسل
      };
    });
    fs.writeFileSync(trackedTokensFile, JSON.stringify(tokensToSave, null, 2), 'utf8');
  } catch (error) {
    console.error('❌ خطأ في حفظ التوكنات المتتبعة:', error.message);
  }
}

// تحميل التوكنات المتتبعة من ملف
function loadTrackedTokens() {
  try {
    if (fs.existsSync(trackedTokensFile)) {
      const savedTokens = JSON.parse(fs.readFileSync(trackedTokensFile, 'utf8'));
      Object.keys(savedTokens).forEach(token => {
        const savedToken = savedTokens[token];
        trackedTokens[token] = {
          ...savedToken,
          startTime: new Date(savedToken.startTime), // تحويل التاريخ من string إلى Date
          page: null,
          rugcheckStatus: savedToken.rugcheckStatus || null, // تحميل حالة rugcheck أو تعيين null إذا لم تكن موجودة
          // التأكد من وجود جميع الخصائص الجديدة
          previousHighPrice: savedToken.previousHighPrice || null,
          currentHighPrice: savedToken.currentHighPrice || null,
          lastRiseTime: savedToken.lastRiseTime ? new Date(savedToken.lastRiseTime) : null,
          rapidRiseAchieved: savedToken.rapidRiseAchieved || false,
          priceRiseHistory: savedToken.priceRiseHistory || [] // تأكد من وجود المصفوفة
        };
      });
      console.log(`📊 تم تحميل ${Object.keys(savedTokens).length} توكن من الملف المحفوظ`);
      
      // إعادة بدء المراقبة للتوكنات التي لم تتوقف
      Object.keys(trackedTokens).forEach(token => {
        const t = trackedTokens[token];
        if (!t.stopped && !t.browserFailed) {
          console.log(`🔄 إعادة بدء مراقبة التوكن: ${token}`);
          startPuppeteerTracking(token, t.startTime).catch(err => {
            console.error(`[${token}] خطأ في إعادة بدء المراقبة: ${err.message}`);
            startManualTracking(token);
          });
        }
      });
    }
  } catch (error) {
    console.error('❌ خطأ في تحميل التوكنات المتتبعة:', error.message);
  }
}

// التحقق من حالة التوكن على rugcheck.xyz
async function checkTokenSafety(token) {
  let page = null;
  try {
    const browser = await getSharedBrowser();
    page = await browser.newPage();
    
    // إعداد user-agent حقيقي
    await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36');
    
    // إزالة متغيرات تدل على الأتمتة
    await page.evaluateOnNewDocument(() => {
      Object.defineProperty(navigator, 'webdriver', { get: () => undefined });
      Object.defineProperty(navigator, 'plugins', { get: () => [1, 2, 3, 4, 5] });
      Object.defineProperty(navigator, 'languages', { get: () => ['en-US', 'en'] });
    });
    
    const rugcheckUrl = `https://rugcheck.xyz/tokens/${token}`;
    console.log(`[${token}] 🔍 التحقق من حالة التوكن على rugcheck.xyz...`);
    
    // التنقل إلى صفحة rugcheck
    await page.goto(rugcheckUrl, { 
      waitUntil: 'domcontentloaded', 
      timeout: 30000 
    });
    
    // انتظار تحميل المحتوى
    await new Promise(resolve => setTimeout(resolve, 5000));
    
    // البحث عن حالة التوكن
    let tokenStatus = null;
    
    try {
      // البحث عن النصوص التي تشير إلى Good أو Danger
      const pageText = await page.evaluate(() => document.body.innerText.toLowerCase());
      
      // البحث عن كلمات مفتاحية بترتيب الأولوية
      if (pageText.includes('danger') || pageText.includes('high risk')) {
        tokenStatus = 'DANGER';
      } else if (pageText.includes('warning') || pageText.includes('medium risk') || pageText.includes('caution')) {
        tokenStatus = 'WARNING';
      } else if (pageText.includes('good') || pageText.includes('green') || pageText.includes('safe') || pageText.includes('low risk')) {
        tokenStatus = 'GOOD';
      }
      
      // محاولة البحث بالعناصر المرئية
      if (!tokenStatus) {
        // البحث عن عناصر بألوان أو فئات تشير إلى الحالة
        const dangerElements = await page.$$eval('*', elements => {
          return elements.some(el => {
            const style = window.getComputedStyle(el);
            const text = el.textContent.toLowerCase();
            const className = el.className.toLowerCase();
            
            // البحث عن العناصر الحمراء أو التي تحتوي على "danger"
            return (style.color.includes('rgb(255') && style.color.includes('0') && style.color.includes('0')) ||
                   (style.backgroundColor.includes('rgb(255') && style.backgroundColor.includes('0') && style.backgroundColor.includes('0')) ||
                   className.includes('danger') ||
                   className.includes('red') ||
                   text.includes('danger') ||
                   text.includes('high risk');
          });
        });
        
        const warningElements = await page.$$eval('*', elements => {
          return elements.some(el => {
            const style = window.getComputedStyle(el);
            const text = el.textContent.toLowerCase();
            const className = el.className.toLowerCase();
            
            // البحث عن العناصر الصفراء/البرتقالية أو التي تحتوي على "warning"
            return (style.color.includes('rgb(255') && style.color.includes('255') && style.color.includes('0')) ||
                   (style.color.includes('rgb(255') && style.color.includes('165') && style.color.includes('0')) ||
                   (style.backgroundColor.includes('rgb(255') && style.backgroundColor.includes('255') && style.backgroundColor.includes('0')) ||
                   (style.backgroundColor.includes('rgb(255') && style.backgroundColor.includes('165') && style.backgroundColor.includes('0')) ||
                   className.includes('warning') ||
                   className.includes('yellow') ||
                   className.includes('orange') ||
                   text.includes('warning') ||
                   text.includes('medium risk') ||
                   text.includes('caution');
          });
        });
        
        const goodElements = await page.$$eval('*', elements => {
          return elements.some(el => {
            const style = window.getComputedStyle(el);
            const text = el.textContent.toLowerCase();
            const className = el.className.toLowerCase();
            
            // البحث عن العناصر الخضراء أو التي تحتوي على "good"
            return (style.color.includes('rgb(0') && style.color.includes('255') && style.color.includes('0')) ||
                   (style.backgroundColor.includes('rgb(0') && style.backgroundColor.includes('255') && style.backgroundColor.includes('0')) ||
                   className.includes('good') ||
                   className.includes('green') ||
                   className.includes('safe') ||
                   text.includes('good') ||
                   text.includes('safe') ||
                   text.includes('low risk');
          });
        });
        
        if (dangerElements) {
          tokenStatus = 'DANGER';
        } else if (warningElements) {
          tokenStatus = 'WARNING';
        } else if (goodElements) {
          tokenStatus = 'GOOD';
        }
      }
    } catch (evaluateError) {
      console.log(`[${token}] خطأ في تقييم محتوى الصفحة: ${evaluateError.message}`);
    }
    
    // إغلاق الصفحة
    await page.close();
    
    console.log(`[${token}] ✅ حالة التوكن: ${tokenStatus || 'غير محدد'}`);
    return tokenStatus;
    
  } catch (error) {
    console.error(`[${token}] ❌ خطأ في التحقق من rugcheck.xyz: ${error.message}`);
    if (page && !page.isClosed()) {
      await page.close();
    }
    return null; // في حالة الخطأ، اعتبر أن التحقق فشل
  }
}

// بدء مراقبة توكن جديد (مع إمكانية العمل بدون puppeteer)
async function startTrackingToken(token, rugcheckStatus = null) {
  if (trackedTokens[token]) {
    // إذا كان التوكن موجود، فقط قم بتحديث حالة rugcheck
    if (rugcheckStatus !== null) {
      trackedTokens[token].rugcheckStatus = rugcheckStatus;
      saveTrackedTokens();
    }
    return;
  }
  
  // التحقق من الحد الأقصى للتوكنات المراقبة
  const activeTokensCount = Object.keys(trackedTokens).filter(t => !trackedTokens[t].stopped).length;
  if (activeTokensCount >= MAX_TRACKED_TOKENS) {
    console.log(`⚠️ تم الوصول للحد الأقصى من التوكنات المراقبة (${MAX_TRACKED_TOKENS}). تخطي التوكن: ${token}`);
    return;
  }
  
  // إضافة التوكن للمراقبة فوراً حتى لو فشل المتصفح
  const startTime = new Date();
  trackedTokens[token] = {
    token,
    startTime,
    firstPrice: null,
    lastPrice: null,
    maxIncrease: 0,
    reached50: false,
    stopped: false,
    page: null,
    browserFailed: false,
    manualMode: false, // وضع يدوي بدون puppeteer
    rugcheckStatus: rugcheckStatus, // حالة التحقق من rugcheck.xyz
    lowLiquidity: null, // حالة السيولة: true = منخفضة، false = طبيعية، null = غير محققة
    // New feature: Price rise comparison
    previousHighPrice: null,
    currentHighPrice: null,
    lastRiseTime: null,
    rapidRiseAchieved: false,
    priceRiseHistory: [] // Array to store price rise events with timestamps
  };

  // حفظ التوكن الجديد
  saveTrackedTokens();
  
  console.log(`[${token}] تم إضافة التوكن للمراقبة وحفظه في الملف`);

  // محاولة استخدام puppeteer، وإذا فشل استخدم وضع يدوي
  try {
    await startPuppeteerTracking(token, startTime);
  } catch (error) {
    console.error(`[${token}] فشل Puppeteer، سيتم التبديل للوضع اليدوي: ${error.message}`);
    startManualTracking(token);
  }
}

// مراقبة بـ Puppeteer
async function startPuppeteerTracking(token, startTime) {

  const url = `https://gmgn.ai/sol/token/${token}`;
  // التحقق من وجود أول سعر محفوظ مسبقاً
  let firstPrice = (trackedTokens[token] && trackedTokens[token].firstPrice && typeof trackedTokens[token].firstPrice === 'number') 
                   ? trackedTokens[token].firstPrice 
                   : null;
  let lastPrice = null;
  let maxIncrease = 0;
  let reached50 = false;
  let stopped = false;

  let browser;
  let page;
  
  try {
    // استخدام المتصفح المشترك مع إعادة المحاولة في حالة الفشل
    let retryCount = 0;
    const maxRetries = 3;
    
    while (retryCount < maxRetries) {
      try {
        browser = await getSharedBrowser();
        
        // التحقق من أن المتصفح متصل ويعمل
        if (!browser.isConnected()) {
          throw new Error('المتصفح غير متصل');
        }
        
        break; // نجح في الحصول على المتصفح
      } catch (error) {
        retryCount++;
        console.log(`[${token}] محاولة ${retryCount}/${maxRetries} للحصول على المتصفح فشلت: ${error.message}`);
        
        // إذا فشل المتصفح المشترك، أعد إنشاءه
        if (sharedBrowser) {
          try {
            await closeSharedBrowser();
          } catch (closeError) {
            console.log(`[${token}] خطأ في إغلاق المتصفح المشترك: ${closeError.message}`);
          }
          sharedBrowser = null;
        }
        
        if (retryCount >= maxRetries) {
          console.error(`[${token}] فشل في الحصول على المتصفح بعد ${maxRetries} محاولات`);
          // التبديل للوضع اليدوي
          startManualTracking(token);
          return;
        }
        
        // انتظار قبل إعادة المحاولة
        await new Promise(r => setTimeout(r, 2000));
      }
    }
    
    page = await browser.newPage();
    
    // إعداد معالجات الأخطاء للصفحة
    page.on('error', (error) => {
      console.log(`[${token}] خطأ في الصفحة: ${error.message}`);
    });
    
    page.on('pageerror', (error) => {
      console.log(`[${token}] خطأ JavaScript في الصفحة: ${error.message}`);
    });
    
    page.on('disconnect', () => {
      console.log(`[${token}] تم قطع اتصال الصفحة`);
    });
    
    // تعيين user-agent حقيقي
    await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36');
    
    // إزالة متغيرات تدل على الأتمتة
    await page.evaluateOnNewDocument(() => {
      Object.defineProperty(navigator, 'webdriver', { get: () => undefined });
      Object.defineProperty(navigator, 'plugins', { get: () => [1, 2, 3, 4, 5] });
      Object.defineProperty(navigator, 'languages', { get: () => ['en-US', 'en'] });
    });
    
    // محاولة التنقل مع إعادة المحاولة في حالة الفشل
    let navigationAttempts = 0;
    const maxNavigationAttempts = 3;
    let navigationSuccessful = false;
    
    while (navigationAttempts < maxNavigationAttempts && !navigationSuccessful) {
      try {
        navigationAttempts++;
        console.log(`[${token}] محاولة التنقل ${navigationAttempts}/${maxNavigationAttempts} إلى: ${url}`);
        
        // إضافة timeout للتنقل مع Promise.race
        await Promise.race([
          page.goto(url, { 
            waitUntil: 'domcontentloaded', 
            timeout: 60000 // تقليل timeout إلى دقيقة واحدة
          }),
          new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Navigation timeout after 60 seconds')), 60000)
          )
        ]);
        
        // انتظار إضافي للتأكد من تحميل المحتوى
        await new Promise(resolve => setTimeout(resolve, 5000)); // تقليل إلى 5 ثواني
        navigationSuccessful = true;
        console.log(`[${token}] تم التنقل بنجاح في المحاولة ${navigationAttempts}`);
        
      } catch (navError) {
        console.log(`[${token}] فشلت محاولة التنقل ${navigationAttempts}: ${navError.message}`);
        
        if (navigationAttempts >= maxNavigationAttempts) {
          throw new Error(`فشل في التنقل بعد ${maxNavigationAttempts} محاولات: ${navError.message}`);
        }
        
        // انتظار قبل إعادة المحاولة
        await new Promise(resolve => setTimeout(resolve, 2000));
      }
    }
  } catch (error) {
    console.error(`[${token}] خطأ في إعداد المتصفح: ${error.message}`);
    if (page) await page.close();
    // التبديل للوضع اليدوي في حالة فشل إعداد المتصفح
    startManualTracking(token);
    return;
  }

  // جلب أول سعر وفحص السيولة
  async function getPrice() {
    try {
      // التحقق من أن الصفحة متصلة
      if (page.isClosed()) {
        console.log(`[${token}] الصفحة مغلقة، لا يمكن جلب السعر`);
        return null;
      }
      
      // انتظار تحميل كامل للصفحة قبل البحث عن السعر
      await new Promise(resolve => setTimeout(resolve, 5000));
      
      // فحص السيولة المنخفضة (بحث موسع)
      try {
        const bodyText = await page.evaluate(() => document.body.innerText);
        // جميع الصيغ الممكنة للتحذير
        const liquidityWarnings = [
          "this token has low liquidity",
          "low liquidity",
          "no liquidity",
          "liquidity is low",
          "insufficient liquidity",
          "not enough liquidity",
          "سيولة منخفضة",
          "لا توجد سيولة"
        ];
        let hasLowLiquidity = liquidityWarnings.some(warning => bodyText.toLowerCase().includes(warning));

        // بحث في عناصر الصفحة عن كلمة liquidity وتحذيرات
        if (!hasLowLiquidity) {
          try {
            hasLowLiquidity = await page.evaluate(() => {
              const warnings = [
                "liquidity",
                "low liquidity",
                "no liquidity",
                "insufficient liquidity",
                "not enough liquidity",
                "سيولة منخفضة",
                "لا توجد سيولة"
              ];
              // ابحث في كل العناصر عن كلمة تحذير
              return Array.from(document.querySelectorAll('*')).some(el => {
                const txt = (el.textContent || "").toLowerCase();
                return warnings.some(w => txt.includes(w));
              });
            });
          } catch {}
        }

        // تحديث معلومة السيولة في trackedTokens
        if (trackedTokens[token]) {
          const previousLiquidityStatus = trackedTokens[token].lowLiquidity;
          trackedTokens[token].lowLiquidity = hasLowLiquidity;
          
          // إذا تغيرت حالة السيولة، أظهر رسالة
          if (previousLiquidityStatus !== hasLowLiquidity) {
            if (hasLowLiquidity) {
              console.log(`[${token}] ⚠️ تم اكتشاف سيولة منخفضة للتوكن - سيتم إيقاف المراقبة`);
              // إيقاف المراقبة عند اكتشاف السيولة المنخفضة
              trackedTokens[token].stopped = true;
              trackedTokens[token].lastPrice = "تم إيقاف المراقبة - سيولة منخفضة";
              saveTrackedTokens();
              return null; // إيقاف جلب السعر
            } else {
              console.log(`[${token}] ✅ تحسنت السيولة للتوكن - استمرار المراقبة`);
            }
          }
          // إذا كانت السيولة منخفضة من البداية، أوقف المراقبة
          if (hasLowLiquidity && previousLiquidityStatus === null) {
            console.log(`[${token}] ⚠️ التوكن يحتوي على سيولة منخفضة - سيتم إيقاف المراقبة`);
            trackedTokens[token].stopped = true;
            trackedTokens[token].lastPrice = "تم إيقاف المراقبة - سيولة منخفضة";
            saveTrackedTokens();
            return null;
          }
        }
      } catch (liquidityError) {
        console.log(`[${token}] خطأ في فحص السيولة: ${liquidityError.message}`);
      }
      
      // محاولة إعادة التنقل إذا كان الإطار منفصلاً
      try {
        await page.evaluate(() => document.title); // اختبار سريع للاتصال
      } catch (frameError) {
        console.log(`[${token}] الإطار منفصل، محاولة إعادة التنقل...`);
        
        try {
          // إغلاق الصفحة الحالية وإنشاء صفحة جديدة
          await page.close();
          page = await browser.newPage();
          
          // إعدادات محسنة لتجنب اكتشاف البوت
          await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36');
          await page.setViewport({ width: 1366, height: 768 });
          
          // إضافة المزيد من إعدادات مكافحة اكتشاف البوت
          await page.evaluateOnNewDocument(() => {
            Object.defineProperty(navigator, 'webdriver', { get: () => undefined });
            Object.defineProperty(navigator, 'plugins', { get: () => [1, 2, 3, 4, 5] });
            Object.defineProperty(navigator, 'languages', { get: () => ['en-US', 'en'] });
            Object.defineProperty(navigator, 'permissions', { get: () => ({ query: () => Promise.resolve({ state: 'granted' }) }) });
          });
          
          // تأخير عشوائي قبل التنقل
          await new Promise(resolve => setTimeout(resolve, Math.random() * 3000 + 2000));
          
          await page.goto(url, { waitUntil: 'networkidle2', timeout: 60000 });
          console.log(`[${token}] تم إنشاء صفحة جديدة وإعادة التنقل بنجاح`);
          
          // انتظار إضافي بعد التنقل
          await new Promise(resolve => setTimeout(resolve, 5000));
          
        } catch (retryError) {
          console.log(`[${token}] فشل في إعادة التنقل: ${retryError.message}`);
          return null;
        }
      }
      
      // جرب أولاً السلكتور .price مع معالجة أفضل للأخطاء
      try {
        console.log(`[${token}] البحث عن selector .price...`);
        await page.waitForSelector('.price', { timeout: 30000 }); // زيادة timeout
        const priceText = await page.$eval('.price', el => el.textContent);
        console.log(`[${token}] نص السعر الخام: "${priceText}"`);
        const price = parseFloat(priceText.replace(/[^\d.eE\-+]/g, ''));
        if (!isNaN(price) && price > 0) {
          console.log(`[${token}] تم جلب السعر من .price:`, price);
          return price;
        }
      } catch (e) {
        console.log(`[${token}] لم يتم العثور على .price أو حدث خطأ:`, e.message);
      }
    } catch (e) {
      console.log(`[${token}] خطأ عام في جلب السعر:`, e.message);
    }
    
    // محاولة البحث عن selectors أخرى شائعة للأسعار
    console.log(`[${token}] البحث عن السعر باستخدام selectors بديلة...`);
    const priceSelectors = [
      '[data-testid="price"]',
      '.token-price', 
      '.current-price',
      '.price-value',
      '[class*="price"]',
      '[id*="price"]',
      '.price',
      '[data-price]',
      '.token-info .price',
      '.price-display'
    ];
    
    for (const selector of priceSelectors) {
      try {
        const element = await page.$(selector);
        if (element) {
          const priceText = await page.evaluate(el => el.textContent || el.innerText, element);
          console.log(`[${token}] نص من ${selector}: "${priceText}"`);
          const price = parseFloat(priceText.replace(/[^\d.eE\-+]/g, ''));
          if (!isNaN(price) && price > 0) {
            console.log(`[${token}] تم جلب السعر من ${selector}:`, price);
            return price;
          }
        }
      } catch (e) {
        // تجاهل وتابع مع السلكتور التالي
      }
    }
    
    // محاولة جلب السعر من عنوان الصفحة
    try {
      const title = await page.title();
      const titlePriceMatch = title.match(/\$([0-9]*\.?[0-9]+(?:[eE][-+]?[0-9]+)?)/);
      if (titlePriceMatch && titlePriceMatch[1]) {
        const priceValue = parseFloat(titlePriceMatch[1]);
        if (!isNaN(priceValue) && priceValue > 0.0000001 && priceValue < 100) {
          console.log(`[${token}] تم جلب السعر من العنوان: ${priceValue}`);
          return priceValue;
        }
      }
    } catch (e) {
      // تجاهل
    }
    
    // إذا لم تعمل السلكتورز، ابحث في النص بطريقة أكثر دقة
    try {
      const bodyText = await page.evaluate(() => document.body.innerText);
      
      // البحث عن أسعار في سياق واضح فقط مع معالجة الأرقام الصغيرة
      const contextualPricePatterns = [
        /price[:\s]*\$([0-9]*\.?[0-9]+(?:[eE][-+]?[0-9]+)?)/gi,
        /current[:\s]*\$([0-9]*\.?[0-9]+(?:[eE][-+]?[0-9]+)?)/gi,
        /\$([0-9]*\.?[0-9]+(?:[eE][-+]?[0-9]+)?)\s*USD/gi,
        /USD[:\s]*([0-9]*\.?[0-9]+(?:[eE][-+]?[0-9]+)?)/gi
      ];
      
      for (const pattern of contextualPricePatterns) {
        const matches = bodyText.matchAll(pattern);
        for (const match of matches) {
          const priceValue = parseFloat(match[1]);
          // فلتر إضافي: تجاهل الأرقام الكبيرة جداً أو الصغيرة جداً
          if (!isNaN(priceValue) && priceValue > 0 && priceValue < 1000000) {
            console.log(`[${token}] تم جلب السعر عبر pattern contextual: ${priceValue}`);
            return priceValue;
          }
        }
      }
      
      // البحث عن الأسعار الصغيرة جداً مع الرموز الخاصة مثل ₅ (subscript 5)
      const smallPricePatterns = [
        /\$0\.0₅([0-9]+)/g, // مثل $0.0₅30829
        /\$0\.0₄([0-9]+)/g, // مثل $0.0₄12345  
        /\$0\.0₃([0-9]+)/g, // مثل $0.0₃56789
        /\$0\.0₆([0-9]+)/g, // مثل $0.0₆98765
        /\$0\.0₇([0-9]+)/g, // مثل $0.0₇45678
        /\$0\.0₈([0-9]+)/g, // مثل $0.0₈12309
        /\$0\.0₉([0-9]+)/g  // مثل $0.0₉87654
      ];
      
      for (const pattern of smallPricePatterns) {
        const matches = bodyText.matchAll(pattern);
        for (const match of matches) {
          const digits = match[1];
          let priceValue;
          
          // تحديد عدد الأصفار بناءً على الرمز المستخدم
          if (pattern.source.includes('₅')) {
            priceValue = parseFloat(`0.00000${digits}`); // 5 أصفار
          } else if (pattern.source.includes('₄')) {
            priceValue = parseFloat(`0.0000${digits}`); // 4 أصفار
          } else if (pattern.source.includes('₃')) {
            priceValue = parseFloat(`0.000${digits}`); // 3 أصفار
          } else if (pattern.source.includes('₆')) {
            priceValue = parseFloat(`0.000000${digits}`); // 6 أصفار
          } else if (pattern.source.includes('₇')) {
            priceValue = parseFloat(`0.0000000${digits}`); // 7 أصفار
          } else if (pattern.source.includes('₈')) {
            priceValue = parseFloat(`0.00000000${digits}`); // 8 أصفار
          } else if (pattern.source.includes('₉')) {
            priceValue = parseFloat(`0.000000000${digits}`); // 9 أصفار
          }
          
          if (!isNaN(priceValue) && priceValue > 0) {
            console.log(`[${token}] تم جلب السعر الصغير: ${priceValue} من النص: ${match[0]}`);
            return priceValue;
          }
        }
      }
      
      // كحل أخير: ابحث عن أول سعر منطقي بشرط أن يكون في نطاق معقول
      const generalPricePattern = /\$([0-9]*\.?[0-9]+(?:[eE][-+]?[0-9]+)?)/g;
      const matches = bodyText.matchAll(generalPricePattern);
      for (const match of matches) {
        const priceValue = parseFloat(match[1]);
        // قبول الأسعار في نطاق معقول للعملات المشفرة الصغيرة
        if (!isNaN(priceValue) && priceValue > 0.0000001 && priceValue < 100) {
          console.log(`[${token}] تم جلب السعر عبر pattern عام: ${priceValue}`);
          return priceValue;
        }
      }
      
      // اطبع جزء من الصفحة للمساعدة في التصحيح
      console.log(`[${token}] لم يتم العثور على السعر، عنوان الصفحة: "${await page.title()}"`);
      console.log(`[${token}] جزء من الصفحة:\n`, bodyText.slice(0, 800));
      
      // محاولة العثور على أي نص يحتوي على علامة الدولار
      const dollarMatches = bodyText.match(/\$[0-9.,eE\-+]+/g);
      if (dollarMatches) {
        console.log(`[${token}] نصوص تحتوي على $:`, dollarMatches.slice(0, 10));
      }
    } catch (e) {
      console.log(`[${token}] خطأ أثناء قراءة نص الصفحة:`, e.message);
    }
    
    // إذا فشل Puppeteer، جرب طريقة API مباشرة
    console.log(`[${token}] فشل Puppeteer، محاولة استخدام API مباشر...`);
    try {
      const https = require('https');
      
      // محاولة استخدام API عام للحصول على بيانات التوكن
      const apiOptions = {
        hostname: 'api.dexscreener.com',
        port: 443,
        path: `/latest/dex/tokens/${token}`,
        method: 'GET',
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
          'Accept': 'application/json',
        }
      };
      
      const apiPrice = await new Promise((resolve, reject) => {
        const req = https.request(apiOptions, (res) => {
          let data = '';
          res.on('data', (chunk) => { data += chunk; });
          res.on('end', () => {
            try {
              const jsonData = JSON.parse(data);
              if (jsonData.pairs && jsonData.pairs.length > 0) {
                const price = parseFloat(jsonData.pairs[0].priceUsd);
                if (!isNaN(price) && price > 0) {
                  console.log(`[${token}] تم جلب السعر من API: ${price}`);
                  resolve(price);
                } else {
                  resolve(null);
                }
              } else {
                resolve(null);
              }
            } catch (parseError) {
              console.log(`[${token}] خطأ في تحليل JSON من API: ${parseError.message}`);
              resolve(null);
            }
          });
        });
        
        req.on('error', (error) => {
          console.log(`[${token}] خطأ في طلب API: ${error.message}`);
          resolve(null);
        });
        
        req.setTimeout(10000, () => {
          console.log(`[${token}] انتهت مهلة طلب API`);
          req.abort();
          resolve(null);
        });
        
        req.end();
      });
      
      if (apiPrice) {
        console.log(`[${token}] نجح في جلب السعر من API: ${apiPrice}`);
        return apiPrice;
      }
    } catch (apiError) {
      console.log(`[${token}] فشل في API request: ${apiError.message}`);
    }
    
    return null;
  }

  // كرر محاولة جلب السعر الأول حتى تحصل على قيمة صحيحة (فقط إذا لم يكن محفوظاً مسبقاً)
  let priceAttempts = 0;
  const maxPriceAttempts = 3; // تقليل المحاولات إلى 3
  
  // إذا كان لدينا أول سعر محفوظ مسبقاً، استخدمه
  if (firstPrice !== null) {
    console.log(`[${token}] استخدام أول سعر محفوظ مسبقاً: ${firstPrice}`);
  } else {
    // إذا لم يكن لدينا أول سعر محفوظ، اجلبه من الموقع
    while (firstPrice === null && priceAttempts < maxPriceAttempts) {
      try {
        console.log(`[${token}] محاولة ${priceAttempts + 1}/${maxPriceAttempts} لجلب السعر...`);
        firstPrice = await getPrice();
        if (firstPrice === null) {
          priceAttempts++;
          if (priceAttempts < maxPriceAttempts) {
            await new Promise(r => setTimeout(r, 5000)); // انتظر 5 ثوانٍ وأعد المحاولة
          }
        }
      } catch (error) {
        priceAttempts++;
        console.error(`[${token}] خطأ في محاولة ${priceAttempts}: ${error.message}`);
        await new Promise(r => setTimeout(r, 3000));
      }
    }
  }

  if (firstPrice === null) {
    console.error(`[${token}] فشل في جلب السعر بعد ${maxPriceAttempts} محاولات. إيقاف المراقبة.`);
    if (browser) await browser.close();
    trackedTokens[token].browserFailed = true;
    trackedTokens[token].firstPrice = "فشل في جلب السعر";
    trackedTokens[token].lastPrice = "غير متاح";
    saveTrackedTokens();
    return;
  }
  // تعيين lastPrice بناءً على الوضع الحالي
  if (trackedTokens[token] && trackedTokens[token].lastPrice && typeof trackedTokens[token].lastPrice === 'number') {
    lastPrice = trackedTokens[token].lastPrice;
  } else {
    lastPrice = firstPrice;
  }
  
  // تحديث البيانات في trackedTokens
  if (trackedTokens[token]) {
    // تحديث firstPrice فقط إذا لم يكن موجوداً من قبل
    if (!trackedTokens[token].firstPrice || typeof trackedTokens[token].firstPrice !== 'number') {
      trackedTokens[token].firstPrice = firstPrice;
    }
    // تحديث lastPrice فقط إذا لم يكن موجوداً من قبل أو كان أقل من القيمة الجديدة
    if (!trackedTokens[token].lastPrice || typeof trackedTokens[token].lastPrice !== 'number' || lastPrice > trackedTokens[token].lastPrice) {
      trackedTokens[token].lastPrice = lastPrice;
    }
    // حفظ الصفحة فقط وليس المتصفح (لأنه مشترك)
    trackedTokens[token].page = page;
    saveTrackedTokens();
  }

  // تحديث السعر كل 10 ثوانٍ
  (async function updateLoop() {
    while (trackedTokens[token] && !trackedTokens[token].stopped) {
      try {
        // التحقق من أن الصفحة ما زالت متصلة
        if (page.isClosed() || !browser.isConnected()) {
          console.log(`[${token}] الصفحة أو المتصفح مغلق، إيقاف المراقبة`);
          break;
        }
        
        const price = await getPrice();
        
        // تحقق من أن التوكن ما زال موجودًا ولم يُحذف أثناء الانتظار
        if (!trackedTokens[token]) break;
        
        if (price) {
          // تحديث lastPrice فقط إذا كان السعر الجديد أعلى من القيمة الحالية
          if (price > trackedTokens[token].lastPrice) {
            // New feature: Track price rise comparison
            const currentTime = new Date();
            const previousPrice = trackedTokens[token].lastPrice;
            
            // Check if this is a significant price increase (10% or more)
            const priceIncreasePercent = ((price - previousPrice) / previousPrice) * 100;
            
            if (priceIncreasePercent >= 10) {
              // Store the previous high price if not already set
              if (trackedTokens[token].previousHighPrice === null) {
                trackedTokens[token].previousHighPrice = previousPrice;
              }
              
              // Update current high price
              trackedTokens[token].currentHighPrice = price;
              
              // Calculate time difference from last rise
              let timeDifference = null;
              if (trackedTokens[token].lastRiseTime) {
                timeDifference = (currentTime - trackedTokens[token].lastRiseTime) / 1000 / 60; // in minutes
              }
              
              // Check if rise happened in less than 2 minutes
              if (timeDifference === null || timeDifference < 2) {
                trackedTokens[token].rapidRiseAchieved = true;
                // التأكد من وجود priceRiseHistory قبل الوصول إليه
                if (!trackedTokens[token].priceRiseHistory) {
                  trackedTokens[token].priceRiseHistory = [];
                }
                trackedTokens[token].priceRiseHistory.push({
                  fromPrice: previousPrice,
                  toPrice: price,
                  increasePercent: priceIncreasePercent,
                  timestamp: currentTime,
                  timeDifference: timeDifference,
                  isRapid: true
                });
              } else {
                // Add to history but mark as not rapid
                // التأكد من وجود priceRiseHistory قبل الوصول إليه
                if (!trackedTokens[token].priceRiseHistory) {
                  trackedTokens[token].priceRiseHistory = [];
                }
                trackedTokens[token].priceRiseHistory.push({
                  fromPrice: previousPrice,
                  toPrice: price,
                  increasePercent: priceIncreasePercent,
                  timestamp: currentTime,
                  timeDifference: timeDifference,
                  isRapid: false
                });
              }
              
              trackedTokens[token].lastRiseTime = currentTime;
            }
            
            trackedTokens[token].lastPrice = price;
          }
          // لا تغير firstPrice بعد تعيينه أول مرة
          const increase = ((price - trackedTokens[token].firstPrice) / trackedTokens[token].firstPrice) * 100;
          if (increase > trackedTokens[token].maxIncrease) trackedTokens[token].maxIncrease = increase;
          // إذا لم يصل بعد إلى 50% وحققها الآن، ثبّت reached50 على true
          if (!trackedTokens[token].reached50 && increase >= 50) {
            trackedTokens[token].reached50 = true;
          }
          
          // حفظ التحديثات كل دقيقة
          const now = Date.now();
          if (!trackedTokens[token].lastSave || now - trackedTokens[token].lastSave > 60000) {
            trackedTokens[token].lastSave = now;
            saveTrackedTokens();
          }
        }
      } catch (error) {
        console.error(`[${token}] خطأ في حلقة التحديث: ${error.message}`);
        // في حالة خطأ الاتصال، انتظر وقت أطول قبل إعادة المحاولة
        await new Promise(r => setTimeout(r, 30000)); // انتظار 30 ثانية
        continue;
      }
      
      await new Promise(r => setTimeout(r, 10000));
    }
    // إغلاق الصفحة فقط وليس المتصفح المشترك
    if (page && !page.isClosed()) {
      await page.close().catch(err => {
        console.log(`[${token}] خطأ في إغلاق الصفحة: ${err.message}`);
      });
    }
  })();
}

// Helper function to check rapid rise conditions
function checkRapidRiseCondition(token, currentPrice, previousPrice, currentTime) {
  if (!trackedTokens[token]) return false;
  
  const priceIncreasePercent = ((currentPrice - previousPrice) / previousPrice) * 100;
  
  // Check if price increased by 10% or more
  if (priceIncreasePercent >= 10) {
    const timeDifference = trackedTokens[token].lastRiseTime 
      ? (currentTime - trackedTokens[token].lastRiseTime) / 1000 / 60 // in minutes
      : null;
    
    // If rise happened in less than 2 minutes, it's considered rapid
    if (timeDifference === null || timeDifference < 2) {
      return true;
    }
  }
  
  return false;
}

// مراقبة يدوية بدون puppeteer (استخدام HTTP requests)
function startManualTracking(token) {
  if (!trackedTokens[token]) return;
  
  trackedTokens[token].manualMode = true;
  trackedTokens[token].firstPrice = "وضع يدوي - غير متاح";
  trackedTokens[token].lastPrice = "يتطلب Chrome";
  trackedTokens[token].rugcheckStatus = null; // لم يتم التحقق في الوضع اليدوي
  // Initialize new properties for manual mode
  trackedTokens[token].previousHighPrice = null;
  trackedTokens[token].currentHighPrice = null;
  trackedTokens[token].lastRiseTime = null;
  trackedTokens[token].rapidRiseAchieved = false;
  trackedTokens[token].priceRiseHistory = [];
  
  // حفظ التحديثات
  saveTrackedTokens();
  
  console.log(`[${token}] بدء المراقبة في الوضع اليدوي (بدون Puppeteer)`);
  console.log(`[${token}] لتفعيل المراقبة الكاملة، قم بتثبيت Chrome: npx puppeteer browsers install chrome`);
}

// حذف التوكن من المراقبة
function stopTrackingToken(token) {
  if (trackedTokens[token]) {
    trackedTokens[token].stopped = true;
    // إغلاق الصفحة إذا كانت مفتوحة (وليس المتصفح المشترك)
    if (trackedTokens[token].page) {
      trackedTokens[token].page.close().catch(err => {
        console.error(`[${token}] خطأ في إغلاق الصفحة: ${err.message}`);
      });
    }
    delete trackedTokens[token];
    // حفظ التغييرات
    saveTrackedTokens();
    console.log(`🗑️ تم حذف التوكن ${token} من المراقبة`);
  }
}

// بيانات الدخول تلقائية للسيرفر
const PHONE_NUMBER = "+967xxxxxxxxx";  // ضع رقمك هنا
const PASSWORD = "YOUR_PASSWORD"; // إذا كان لديك كلمة مرور 2FA
const PHONE_CODE = undefined; // يمكن تركه undefined ليتم تجاهله

const apiId = 23299626;
const apiHash = "89de50a19288ec535e8b008ae2ff268d";

console.log("🚀 البوت يعمل الآن 24 ساعة على السيرفر!");

// تنظيف العمليات المعلقة من Chrome عند بدء البرنامج
function cleanupChromeProcesses() {
  try {
    const { exec } = require('child_process');
    // إنهاء عمليات Chrome المعلقة على Windows
    exec('taskkill /f /im chrome.exe /t', (error, stdout, stderr) => {
      if (!error) {
        console.log('🧹 تم تنظيف عمليات Chrome المعلقة');
      }
    });
  } catch (error) {
    // تجاهل الأخطاء
  }
}

// تنظيف العمليات المعلقة عند بدء البرنامج
cleanupChromeProcesses();

// إنشاء المتصفح المشترك عند بدء البرنامج
async function initializeSharedBrowser() {
  try {
    await getSharedBrowser();
    console.log('✅ تم تجهيز المتصفح المشترك بنجاح');
  } catch (error) {
    console.error('⚠️ فشل في تجهيز المتصفح المشترك:', error.message);
    console.log('📱 سيتم التشغيل في الوضع اليدوي فقط');
  }
}

// تجهيز المتصفح وتحميل التوكنات
initializeSharedBrowser().then(() => {
  // تحميل التوكنات المحفوظة بعد تجهيز المتصفح
  loadTrackedTokens();
}).catch(err => {
  console.error('خطأ في التهيئة:', err.message);
  // تحميل التوكنات حتى لو فشل المتصفح
  loadTrackedTokens();
});

// دالة لتسجيل الدخول والخروج
function logLoginLogout(type) {
  const logFile = 'login_logout_log.txt';
  const now = new Date().toISOString();
  fs.appendFileSync(logFile, `${type},${now}\n`, 'utf8');
}

// تسجيل الدخول
logLoginLogout('login');

// نحاول تحميل الجلسة من ملف
let stringSession = new StringSession("");

if (fs.existsSync("session.txt")) {
  const savedSession = fs.readFileSync("session.txt", "utf8");
  stringSession = new StringSession(savedSession.trim());
}

(async () => {
  console.log("📲 بدء الاتصال بتليجرام...");
  const client = new TelegramClient(stringSession, apiId, apiHash, {
    connectionRetries: 5,
  });

  // تسجيل الدخول عند الحاجة فقط
  try {
    await client.start({
      phoneNumber: async () => PHONE_NUMBER,
      password: async () => PASSWORD,
      phoneCode: async () => PHONE_CODE,
      onError: (err) => console.log("❌ خطأ:", err),
    });
  } catch (err) {
    if (err.errorMessage === 'AUTH_KEY_DUPLICATED') {
      console.error('❌ AUTH_KEY_DUPLICATED: سيتم حذف الجلسة القديمة وإنشاء جلسة جديدة.');
      fs.unlinkSync('session.txt'); // حذف ملف الجلسة القديمة
      stringSession = new StringSession(""); // إعادة تعيين الجلسة
      await client.start({
        phoneNumber: async () => PHONE_NUMBER,
        password: async () => PASSWORD,
        phoneCode: async () => PHONE_CODE,
        onError: (err) => console.log("❌ خطأ:", err),
      });
    } else {
      throw err; // إعادة رمي الخطأ إذا لم يكن AUTH_KEY_DUPLICATED
    }
  }

  console.log("✅ تم تسجيل الدخول!");
  const sessionString = client.session.save();

  // حفظ الجلسة للاستخدام التالي
  fs.writeFileSync("session.txt", sessionString);
  console.log("💾 تم حفظ الجلسة في session.txt");

  await client.sendMessage("me", { message: "🚀 بوت الإشعارات شغال!" });

  // تحقق من الانضمام للبوتات المطلوبة مرة واحدة فقط في الحياة
  const joinedBotsFile = 'joined_bots.txt';
  if (!fs.existsSync(joinedBotsFile)) {
    try {
      // قائمة البوتات المطلوبة
      const botsToJoin = ['GMGN_sol_bot', 'solBigamout'];
      for (const bot of botsToJoin) {
        // أرسل فقط للبوتات التي تنتهي بـ _bot
        if (bot.endsWith('_bot')) {
          await client.sendMessage(bot, { message: '/start' });
          await sleep(2000);
        } else {
          console.log(`⚠️ تخطي ${bot}: ليس بوت تليجرام.`);
        }
      }
      fs.writeFileSync(joinedBotsFile, 'done');
      console.log('✅ تم الانضمام لكل البوتات المطلوبة لأول مرة.');
    } catch (err) {
      console.error('❌ خطأ أثناء الانضمام للبوتات:', err.message);
    }
  }

  // التتبع والتوجيه
  client.addEventHandler(async (update) => {
    try {
      // تعديل شروط الفلترة لإضافة الفرز الرابع
      if (update.message && typeof update.message.message === "string") {
        const msg = update.message;
        const text = msg.message;

        // فلترة الرسائل التي تحتوي على "counts: 1" أو أكثر و"25 SOL" أو أكثر
        if (/\bcounts:\s*(\d+)\b/i.test(text) && parseInt(text.match(/\bcounts:\s*(\d+)\b/i)[1]) >= 1 &&
            /(2[5-9]|[3-9]\d|\d{3,})\.\d{2}\s*SOL(\D|$)/.test(text)) {

          // فلترة "5m" بحيث تكون بين 0% و 3000%
          const fiveMinMatch = text.match(/5m\s*\((\d+\.\d+)%\)/);
          if (fiveMinMatch) {
            const fiveMinPercentage = parseFloat(fiveMinMatch[1]);
            if (fiveMinPercentage > 3000) {
              console.log(`⚠️ النسبة 5m (${fiveMinPercentage}%) أكبر من 3000%. تخطي.`);
              return;
            }
          }

          // الفرز الرابع: التحقق من أن عدد الأيام (d) يساوي 0
          const ageMatch = text.match(/age:\s*(\d+)d\s*(\d+)h/);
          if (ageMatch) {
            const days = parseInt(ageMatch[1]);
            if (days !== 0) {
              console.log(`⚠️ عدد الأيام (d) ليس 0. تخطي.`);
              return;
            }
          }

          // فلترة السعر price: $... يجب أن يكون أقل من 0.01
          const priceMatch = text.match(/price:\s*\$?([\deE\.-]+)/i);
          if (priceMatch && priceMatch[1]) {
            let priceValue = parseFloat(priceMatch[1]);
            if (isNaN(priceValue)) {
              // محاولة التحويل من صيغة علمية
              try {
                priceValue = Number(priceMatch[1]);
              } catch {}
            }
            if (!(priceValue < 0.01)) {
              console.log(`⚠️ السعر ${priceValue} أكبر أو يساوي 0.01. تخطي.`);
              return;
            }
          } else {
            // إذا لم يوجد سعر، تخطى
            console.log('⚠️ لم يتم العثور على السعر في الرسالة. تخطي.');
            return;
          }

          const startTime = performance.now();
          // استخراج التوكن بعد ca:
          const caMatch = text.match(/ca:\s*([\w]+)/);
          if (caMatch && caMatch[1]) {
            const token = caMatch[1];
            if (sentTokens.has(token)) {
              console.log(`⚠️ التوكن ${token} تم إرساله مسبقًا. تخطي.`);
              return;
            }
            
            // طباعة التوكن فقط بدون ca:
            console.log(token);
            
            // التحقق من حالة التوكن على rugcheck.xyz قبل الإرسال
            console.log(`[${token}] 🔍 بدء التحقق من حالة التوكن على rugcheck.xyz...`);
            const tokenSafety = await checkTokenSafety(token);
            
            // حفظ حالة rugcheck في بيانات التوكن للعرض لاحقاً
            if (trackedTokens[token]) {
              trackedTokens[token].rugcheckStatus = tokenSafety;
            }
            
            if (tokenSafety === 'DANGER') {
              console.log(`[${token}] ❌ تم رفض التوكن - مصنف كـ DANGER على rugcheck.xyz`);
              console.log(`[${token}] 🚫 لن يتم إرسال أمر الشراء أو إرسال التوكن إلى GMGN`);
              
              // بدء مراقبة التوكن حتى لو تم رفضه (لأغراض الإحصائيات)
              startTrackingToken(token, tokenSafety).catch(err => {
                console.error(`[${token}] خطأ في بدء المراقبة: ${err.message}`);
              });
              
              return; // عدم إرسال التوكن إذا كان خطر
            } else if (tokenSafety === 'WARNING') {
              console.log(`[${token}] ⚠️ تحذير - التوكن مصنف كـ WARNING على rugcheck.xyz`);
              console.log(`[${token}] 🤔 لن يتم إرسال أمر الشراء كإجراء احترازي`);
              
              // بدء مراقبة التوكن حتى لو تم رفضه (لأغراض الإحصائيات)
              startTrackingToken(token, tokenSafety).catch(err => {
                console.error(`[${token}] خطأ في بدء المراقبة: ${err.message}`);
              });
              
              return; // عدم إرسال التوكن إذا كان تحذير
            } else if (tokenSafety === 'GOOD') {
              console.log(`[${token}] ✅ التوكن آمن - مصنف كـ GOOD على rugcheck.xyz`);
              console.log(`[${token}] 🚀 سيتم المتابعة مع إرسال أمر الشراء والتوكن إلى GMGN`);
            } else {
              console.log(`[${token}] ⚠️ لم يتم تحديد حالة التوكن على rugcheck.xyz (ربما خطأ في التحقق)`);
              console.log(`[${token}] 🤔 سيتم المتابعة مع الحذر...`);
            }
            
            // حفظ التوكن في ملف لاستخدامه في بوت sniperoo
            fs.writeFileSync('last_token.txt', token, 'utf8');

            // إرسال أمر الشراء والتوكن فقط إذا كان التوكن آمن (GOOD) أو غير محدد (ليس DANGER أو WARNING)
            if (tokenSafety !== 'DANGER' && tokenSafety !== 'WARNING') {
              // إرسال أمر الشراء والتوكن في نفس اللحظة (زمن بلانك)
              const buyMsg = `/buy ${token} ${buyPrice}`;
              client.sendMessage(botUsername, { message: buyMsg });
              client.sendMessage(botUsername, { message: token });
              console.log('✅ تم إرسال أمر الشراء المباشر:', buyMsg);
              console.log('📩 تم إرسال التكوين لمعرفة السعر بعد الشراء.');

              // إضافة التوكن إلى القائمة المرسلة
              sentTokens.add(token);
              fs.appendFileSync(sentTokensFile, `${token}\n`, 'utf8');

              // بدء مراقبة التوكن (مع معالجة الأخطاء)
              startTrackingToken(token, tokenSafety).catch(err => {
                console.error(`[${token}] خطأ في بدء المراقبة: ${err.message}`);
              });
            } else {
              console.log(`[${token}] 🛑 تم تخطي إرسال التوكن بسبب تصنيفه كـ ${tokenSafety} على rugcheck.xyz`);
              
              // بدء مراقبة التوكن حتى لو تم رفضه (لأغراض الإحصائيات) مع تمرير الحالة
              startTrackingToken(token, tokenSafety).catch(err => {
                console.error(`[${token}] خطأ في بدء المراقبة: ${err.message}`);
              });
            }

            const endTime = performance.now();
            const executionTimeLog = `⏱️ وقت التنفيذ للتوكن ${token}: ${(endTime - startTime).toFixed(2)} مللي ثانية.`;
            console.log(executionTimeLog);
            executionLogsBuffer.push(`${executionTimeLog}\n`);
          }
        }
      }
    } catch (err) {
      console.error("❌ خطأ أثناء التوجيه:", err.message);
    }
  });
})();

const botUsername = 'GMGN_sol_bot';

// دالة التداول التلقائي في بوت GMGN
async function tradeInGMGNBot(client, token) {
  const lastStartFile = 'gmgn_last_start.txt';
  let shouldSendStart = true;
  try {
    // تحقق من آخر إرسال لـ /start
    if (fs.existsSync(lastStartFile)) {
      const lastStartDate = fs.readFileSync(lastStartFile, 'utf8').trim();
      const today = new Date().toISOString().slice(0, 10);
      if (lastStartDate === today) {
        shouldSendStart = false;
      }
    }
    // إرسال /start مرة واحدة فقط يومياً
    if (shouldSendStart) {
      await client.sendMessage(botUsername, { message: '/start' });
      fs.writeFileSync(lastStartFile, new Date().toISOString().slice(0, 10));
      await sleep(2000);
    }
    // إرسال التوكن
    await client.sendMessage(botUsername, { message: token });
    await sleep(3000);

    // استقبال رسائل البوت وطباعة كل رسالة والبحث عن السعر
    let price = null;
    let done = false;
    let lastBotMessage = null;
    const handler = async (update) => {
      // تحقق من أن الرسالة من بوت GMGN بناءً على اسم المستخدم أو peerId
      if (update.message && update.message.peerId && (
            (update.message.peerId.userId && update.message.peerId.userId.toString().includes('GMGN')) ||
            (update.message.peerId.channelId && botUsername.includes('GMGN'))
          )) {
        const text = update.message.message;
        lastBotMessage = text;
        // تحقق أن الرسالة تحتوي على التوكن المطلوب
        if (text.includes(token)) {
          // استخراج السعر من الرسالة
          let priceMatch = text.match(/price:\s*\$?([\d\.]+)/i);
          if (priceMatch && priceMatch[1]) {
            price = parseFloat(priceMatch[1]);
            done = true;
            // طباعة السعر فقط بدون باقي الرسالة وبدون علامة الدولار
            console.log('📩 السعر من GMGN: ' + priceMatch[1]);
            // حساب السعر الجديد بزيادة 1000%
            const newPrice = (price * 10).toFixed(6);
            // إرسال أمر التداول مباشرة
            const orderMsg = `/create limitbuy ${token} 0.5@${newPrice} -exp 86400`;
            await client.sendMessage(botUsername, { message: orderMsg });
            console.log('✅ تم إرسال أمر التداول:', orderMsg);
          } else {
            // إذا لم يوجد سعر، اطبع الرسالة كاملة
            console.log('📩 رسالة من GMGN:\n' + text);
          }
        }
      }
    };
    client.addEventHandler(handler);
    // انتظر حتى يتم استقبال السعر أو انتهاء المهلة
    let tries = 0;
    while (!done && tries < 10) {
      await sleep(1000);
      tries++;
    }
    client.removeEventHandler(handler);
    if (!price) {
      console.log('📩 رد البوت بعد ارسال التوكن:\n' + (lastBotMessage || 'لم يتم استقبال أي رسالة من البوت بعد إرسال التوكن'));
      return;
    }
    // حساب السعر الجديد بزيادة 1000%
    const newPrice = (price * 10).toFixed(6);
    // إرسال أمر التداول
    const orderMsg = `/create limitbuy ${token} 0.5@${newPrice} -exp 86400`;
    await client.sendMessage(botUsername, { message: orderMsg });
    console.log('✅ تم إرسال أمر التداول:', orderMsg);
  } catch (err) {
    console.error('❌ خطأ في التداول مع GMGN:', err.message);
  }
}

// دالة تأخير بسيطة
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

let buyPrice = 0.5; // السعر الافتراضي

const PORT = process.env.PORT || 1010;
const server = http.createServer((req, res) => {
  // Health check endpoint للتوافق مع Render
  if (req.method === "GET" && req.url === "/health") {
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(JSON.stringify({ status: "OK", timestamp: new Date().toISOString() }));
    return;
  }

  // Root endpoint للتحقق من حالة البوت
  if (req.method === "GET" && req.url === "/") {
    res.writeHead(200, { "Content-Type": "text/html; charset=utf-8" });
    res.end(`
      <div style='text-align:center; font-family: Arial, sans-serif; padding: 50px;'>
        <h1 style='color: #0078D7;'>🚀 البوت يعمل بنجاح!</h1>
        <p style='font-size: 1.2em; color: #333;'>الوقت الحالي: ${new Date().toLocaleString('ar-SA')}</p>
        <p><a href="/track_token" style='color: #0078D7; text-decoration: none;'>📊 متابعة التوكنات</a></p>
      </div>
    `);
    return;
  }

  if (req.method === "POST" && req.url === "/delete-all") {
    // مسح محتويات ملف السجلات
    fs.writeFileSync('execution_logs.txt', '', 'utf8');
    res.writeHead(200, { "Content-Type": "text/html; charset=utf-8" });
    res.end(`
      <div style='text-align:center;'>
        <div style='font-size:2em;'>🚀 تم مسح جميع السجلات بنجاح!</div>
        <a href="/" style='font-size:1.5em; color:#0078D7;'>العودة إلى الصفحة الرئيسية</a>
      </div>
    `);
    return;
  }

  if (req.method === "POST" && req.url === "/update-price") {
    let body = "";
    req.on("data", chunk => {
      body += chunk.toString();
    });
    req.on("end", () => {
      const params = new URLSearchParams(body);
      const newPrice = parseFloat(params.get("price"));
      if (!isNaN(newPrice) && newPrice > 0) {
        buyPrice = newPrice;
        res.writeHead(200, { "Content-Type": "text/html; charset=utf-8" });
        res.end(`
          <div style='text-align:center;'>
            <div style='font-size:2em;'>✅ تم تحديث السعر بنجاح إلى: ${buyPrice}</div>
            <a href="/" style='font-size:1.5em; color:#0078D7;'>العودة إلى الصفحة الرئيسية</a>
          </div>
        `);
      } else {
        res.writeHead(400, { "Content-Type": "text/html; charset=utf-8" });
        res.end(`
          <div style='text-align:center;'>
            <div style='font-size:2em; color:red;'>❌ السعر المدخل غير صالح!</div>
            <a href="/" style='font-size:1.5em; color:#0078D7;'>العودة إلى الصفحة الرئيسية</a>
          </div>
        `);
      }
    });
    return;
  }

  // ...existing code...
  if (req.method === "GET" && req.url.startsWith("/track_token")) {
    res.writeHead(200, { "Content-Type": "text/html; charset=utf-8" });
    res.end(`
      <html lang="ar">
      <head>
        <title>Token Tracker</title>
        <meta http-equiv="refresh" content="10">
        <style>
          body { font-family: Tahoma, Arial, sans-serif; background: #f7f7fa; margin: 0; padding: 0; direction: rtl; }
          h2 { text-align: center; color: #0078D7; margin-top: 30px; letter-spacing: 1px; }
          .tokens-container { max-width: 700px; margin: 30px auto; }
          .token-block {
            background: #fff;
            border: 1px solid #e0e0e0;
            box-shadow: 0 2px 8px #0001;
            padding: 18px 22px 12px 22px;
            margin-bottom: 18px;
            border-radius: 10px;
            transition: box-shadow 0.2s;
            position: relative;
          }
          .token-block:hover { box-shadow: 0 4px 16px #0002; }
          .token-label { color: #333; font-weight: bold; display: inline-block; min-width: 170px; }
          .token-value { color: #0078D7; font-weight: bold; }
          .token-status { font-size: 1.1em; }
          .delete-btn {
            background: #e53935;
            color: #fff;
            border: none;
            border-radius: 5px;
            padding: 7px 18px;
            font-size: 1em;
            cursor: pointer;
            margin-top: 10px;
            transition: background 0.2s;
          }
          .delete-btn:hover { background: #b71c1c; }
          .token-row { margin-bottom: 7px; }
        </style>
      </head>
      <body>
        <h2>متابعة التوكنات (Token Tracker)</h2>
        <div style='text-align: center; margin-bottom: 20px; color: #666; font-size: 0.9em;'>
          🔄 التوكنات محفوظة تلقائياً وتستمر المراقبة حتى بعد إعادة تشغيل البرنامج<br/>
          🛡️ يتم التحقق من كل توكن على rugcheck.xyz: <span style="color: #4CAF50;">✅ آمن</span> | <span style="color: #FF9800;">🔶 تحذير</span> | <span style="color: #F44336;">⚠️ خطر</span> | <span style="color: #666;">❓ غير محقق</span><br/>
          💧 يتم فحص السيولة من gmgn.ai: <span style="color: #4CAF50;">✅ سيولة طبيعية</span> | <span style="color: #FF5722;">⚠️ سيولة منخفضة</span> | <span style="color: #666;">❓ غير محققة</span><br/>
          🚫 <strong>المراقبة تتوقف تلقائياً عند اكتشاف سيولة منخفضة</strong>
        </div>
        <div class="tokens-container">
        ${Object.values(trackedTokens)
          .sort((a, b) => b.startTime - a.startTime) // الأحدث أولاً
          .map(t => {
            let percent = '';
            let firstPriceDisplay = '';
            let lastPriceDisplay = '';
            let priceComparison = '';
            
            if (t.browserFailed) {
              firstPriceDisplay = '⚠️ فشل في تحميل المتصفح';
              lastPriceDisplay = '❌ غير متاح';
              percent = 'غير متاح';
              priceComparison = 'غير متاح';
            } else if (t.firstPrice && t.lastPrice && typeof t.firstPrice === 'number' && typeof t.lastPrice === 'number') {
              const p = ((t.lastPrice - t.firstPrice) / t.firstPrice) * 100;
              percent = (p >= 0 ? '+' : '') + p.toFixed(2) + '%';
              firstPriceDisplay = t.firstPrice + '$';
              lastPriceDisplay = t.lastPrice + '$';
              
              // مقارنة النسبة بين أعلى سعر والسعر الأول
              const ratio = (t.lastPrice / t.firstPrice).toFixed(2);
              if (ratio >= 10) {
                priceComparison = `🚀 ارتفع ${ratio}x من السعر الأول`;
              } else if (ratio >= 5) {
                priceComparison = `📈 ارتفع ${ratio}x من السعر الأول`;
              } else if (ratio >= 2) {
                priceComparison = `⬆️ ارتفع ${ratio}x من السعر الأول`;
              } else if (ratio > 1) {
                priceComparison = `🔼 ارتفع ${ratio}x من السعر الأول`;
              } else if (ratio == 1) {
                priceComparison = `➡️ لا تغيير في السعر`;
              } else {
                priceComparison = `🔻 انخفض إلى ${ratio}x من السعر الأول`;
              }
            } else if (t.firstPrice && typeof t.firstPrice === 'string') {
              firstPriceDisplay = t.firstPrice;
              lastPriceDisplay = t.lastPrice || 'جاري التحميل...';
              percent = 'غير متاح';
              priceComparison = 'غير متاح';
            } else {
              firstPriceDisplay = 'جاري التحميل...';
              lastPriceDisplay = 'جاري التحميل...';
              percent = '...';
              priceComparison = '...';
            }
            
            // حساب مدة المراقبة hh:mm:ss
            let duration = '...';
            if (t.startTime) {
              const ms = Date.now() - t.startTime.getTime();
              const totalSeconds = Math.floor(ms / 1000);
              const hours = Math.floor(totalSeconds / 3600);
              const minutes = Math.floor((totalSeconds % 3600) / 60);
              const seconds = totalSeconds % 60;
              duration = `${hours.toString().padStart(2,'0')}:${minutes.toString().padStart(2,'0')}:${seconds.toString().padStart(2,'0')}`;
            }
            
            const statusIcon = t.browserFailed ? '⚠️' : t.stopped && t.lowLiquidity ? '🚫' : (t.reached50 ? '✅️' : '❌️');
            const statusText = t.browserFailed ? 'فشل المتصفح' : t.stopped && t.lowLiquidity ? 'توقفت - سيولة منخفضة' : (t.reached50 ? 'وصل 50%+' : 'لم يصل بعد');
            
            // معلومات السيولة
            let liquidityIcon = '💧';
            let liquidityText = 'طبيعية';
            let liquidityColor = '#4CAF50';
            
            if (t.lowLiquidity === true) {
              liquidityIcon = '⚠️';
              liquidityText = 'لم يعد يوجد سيولة أو سيولة أصبحت منخفضة';
              liquidityColor = '#FF5722';
            } else if (t.lowLiquidity === false) {
              liquidityIcon = '✅';
              liquidityText = 'سيولة طبيعية';
              liquidityColor = '#4CAF50';
            } else {
              liquidityIcon = '❓';
              liquidityText = 'غير محققة';
              liquidityColor = '#666';
            }
            
            // New feature: Price rise comparison status
            let rapidRiseStatus = '';
            let rapidRiseIcon = '';
            if (t.rapidRiseAchieved) {
              rapidRiseIcon = '✅';
              rapidRiseStatus = 'حقق ارتفاع سريع 10%+ في أقل من دقيقتين';
            } else if (t.priceRiseHistory && t.priceRiseHistory.length > 0) {
              const hasSlowRise = t.priceRiseHistory.some(rise => rise.increasePercent >= 10 && !rise.isRapid);
              if (hasSlowRise) {
                rapidRiseIcon = '⏳';
                rapidRiseStatus = 'ارتفع 10%+ لكن في أكثر من دقيقتين - لم يُحتسب';
              } else {
                rapidRiseIcon = '⭕';
                rapidRiseStatus = 'لم يحقق ارتفاع 10% بعد';
              }
            } else {
              rapidRiseIcon = '⭕';
              rapidRiseStatus = 'لم يحقق ارتفاع 10% بعد';
            }
            
            // Price comparison display
            let priceComparisonDisplay = 'غير متوفر';
            if (t.previousHighPrice && t.currentHighPrice) {
              const priceRatio = (t.currentHighPrice / t.previousHighPrice).toFixed(4);
              priceComparisonDisplay = `السعر السابق: ${t.previousHighPrice.toFixed(8)} → السعر الحالي: ${t.currentHighPrice.toFixed(8)} (نسبة: ${priceRatio}x)`;
            }
            
            return `
              <div class="token-block" style="${t.browserFailed ? 'border-left: 4px solid #ff9800;' : ''}">
                <div class="token-row"><span class="token-label">⏰ تاريخ ووقت بداية المراقبة:</span> <span>${t.startTime.toLocaleString('sv-SE').replace('T',' ')}</span></div>
                <div class="token-row"><span class="token-label">🔹 التوكن:</span> <span class="token-value">${t.token}</span></div>
                <div class="token-row"><span class="token-label">🛡️ حالة rugcheck.xyz:</span> <span style="color: ${t.rugcheckStatus === 'GOOD' ? '#4CAF50' : t.rugcheckStatus === 'DANGER' ? '#F44336' : t.rugcheckStatus === 'WARNING' ? '#FF9800' : '#666'}; font-weight: bold;">${t.rugcheckStatus === 'GOOD' ? '✅ آمن' : t.rugcheckStatus === 'DANGER' ? '⚠️ خطر' : t.rugcheckStatus === 'WARNING' ? '🔶 تحذير' : '❓ لم يتم التحقق'}</span></div>
                <div class="token-row"><span class="token-label">� حالة السيولة:</span> <span style="color: ${liquidityColor}; font-weight: bold;">${liquidityIcon} ${liquidityText}</span></div>
                <div class="token-row"><span class="token-label">�💵 أول سعر مراقب:</span> <span>${firstPriceDisplay}</span></div>
                <div class="token-row"><span class="token-label">📈 أعلى سعر وصله:</span> <span style="color:green">${lastPriceDisplay}</span></div>
                <div class="token-row"><span class="token-label">📊 نسبة الارتفاع من أول سعر:</span> <span>${percent}</span></div>
                <div class="token-row"><span class="token-label">� مقارنة النسبة بين الأسعار:</span> <span style="font-weight:bold; color:#ff6b35;">${priceComparison}</span></div>
                <div class="token-row"><span class="token-label">�🚀 الحالة:</span> <span class="token-status">${statusIcon} ${statusText}</span></div>
                <div class="token-row"><span class="token-label">⏳ مدة المراقبة:</span> <span>${duration}</span></div>
                <div class="token-row"><span class="token-label">🔍 مقارنة ارتفاعات الأسعار:</span> <span style="font-weight:bold; color:#2196F3;">${priceComparisonDisplay}</span></div>
                <div class="token-row"><span class="token-label">⚡ الارتفاع السريع:</span> <span class="token-status" style="color: ${t.rapidRiseAchieved ? '#4CAF50' : '#FF9800'};">${rapidRiseIcon} ${rapidRiseStatus}</span></div>
                <form method="POST" action="/delete_token" style="display:inline;">
                  <input type="hidden" name="token" value="${t.token}" />
                  <button type="submit" class="delete-btn">حذف من المراقبة</button>
                </form>
              </div>
            `;
          }).join('')}
        </div>
        ${Object.keys(trackedTokens).length === 0 ? '<div style="text-align: center; color: #666; font-size: 1.2em; margin-top: 50px;">📭 لا توجد توكنات قيد المراقبة حالياً</div>' : ''}
      </body>
      </html>
    `);
    return;
  }

  if (req.method === "POST" && req.url === "/delete_token") {
    let body = "";
    req.on("data", chunk => { body += chunk.toString(); });
    req.on("end", () => {
      const params = new URLSearchParams(body);
      const token = params.get("token");
      stopTrackingToken(token);
      res.writeHead(302, { Location: "/track_token" });
      res.end();
    });
    return;
  }
  // ...existing code...
}).listen(PORT, '0.0.0.0', () => {
  console.log(`🌐 HTTP Server running on port ${PORT}`);
  console.log(`🌍 Server accessible at: http://0.0.0.0:${PORT}`);
});

// استخدام URL ديناميكي للـ keep-alive بناءً على البيئة
const KEEP_ALIVE_URL = process.env.RENDER_EXTERNAL_URL || "https://cdcd.onrender.com";
setInterval(() => {
  const targetUrl = KEEP_ALIVE_URL + "/health";
  const protocol = targetUrl.startsWith('https://') ? https : http;
  
  protocol.get(targetUrl, (res) => {
    console.log(`🔄 Keep Alive Ping: ${targetUrl} - Status: ${res.statusCode}`);
  }).on("error", (e) => {
    console.error(`❌ Keep Alive Error: ${e.message}`);
  });
}, 10 * 60 * 1000); // كل 10 دقائق

// تسجيل الخروج عند إنهاء العملية
process.on('exit', () => {
  logLoginLogout('logout');
  saveTrackedTokens();
});

process.on('SIGINT', async () => {
  console.log('\n🛑 تم استلام إشارة إيقاف البرنامج...');
  logLoginLogout('logout');
  saveTrackedTokens();
  await closeSharedBrowser();
  console.log('👋 تم إنهاء البرنامج بأمان');
  process.exit(0);
});

process.on('SIGTERM', async () => {
  console.log('\n🛑 تم استلام إشارة إنهاء البرنامج...');
  logLoginLogout('logout');
  saveTrackedTokens();
  await closeSharedBrowser();
  console.log('👋 تم إنهاء البرنامج بأمان');
  process.exit(0);
});

// معالجة الأخطاء غير المتوقعة
process.on('uncaughtException', async (error) => {
  console.error('❌ خطأ غير متوقع:', error);
  await closeSharedBrowser();
  process.exit(1);
});

process.on('unhandledRejection', async (reason, promise) => {
  console.error('❌ وعد مرفوض:', reason);
  await closeSharedBrowser();
  process.exit(1);
});

const sentTokensFile = 'sent_tokens.txt';
let sentTokens = new Set();
if (fs.existsSync(sentTokensFile)) {
  const tokens = fs.readFileSync(sentTokensFile, 'utf8').split('\n').filter(Boolean);
  sentTokens = new Set(tokens);
}

// تحسين الأداء عبر تقليل عمليات الإدخال/الإخراج (I/O) والكتابة المجمعة
const executionLogsBuffer = [];

// كتابة السجلات المجمعة إلى الملف بشكل دوري
setInterval(() => {
  if (executionLogsBuffer.length > 0) {
    fs.appendFileSync('execution_logs.txt', executionLogsBuffer.join(''), 'utf8');
    executionLogsBuffer.length = 0;
  }
}, 5000); // كل 5 ثوانٍ

// حفظ التوكنات المتتبعة كل 5 دقائق
setInterval(() => {
  saveTrackedTokens();
}, 300000); // كل 5 دقائق

// تنظيف الذاكرة كل 10 دقائق
setInterval(() => {
  if (global.gc) {
    global.gc();
    console.log('🧹 تم تنظيف الذاكرة');
  }
}, 600000); // كل 10 دقائق
