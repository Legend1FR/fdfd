const { TelegramClient } = require("telegram");
const { StringSession } = require("telegram/sessions");
const fs = require("fs");
const input = require("input");
const http = require("http");
const https = require("https");
const { exec } = require("child_process"); // Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø¥Ù„Ù‰ Ø§Ù„Ø¨ÙˆØª
const multer = require("multer"); // Ø¥Ø¶Ø§ÙØ© Ù…ÙƒØªØ¨Ø© multer Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø±ÙØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª


const PHONE_NUMBER = "+967781430676"; // Ø¶Ø¹ Ø±Ù‚Ù…Ùƒ Ù‡Ù†Ø§
const PASSWORD = "YOUR_PASSWORD"; // Ø¥Ø°Ø§ ÙƒØ§Ù† Ù„Ø¯ÙŠÙƒ ÙƒÙ„Ù…Ø© Ù…Ø±ÙˆØ± 2FA
const PHONE_CODE = undefined; // ÙŠÙ…ÙƒÙ† ØªØ±ÙƒÙ‡ undefined Ù„ÙŠØªÙ… ØªØ¬Ø§Ù‡Ù„Ù‡

const apiId = 23299626;
const apiHash = "89de50a19288ec535e8b008ae2ff268d";

console.log("ğŸš€ Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø§Ù„Ø¢Ù† 24 Ø³Ø§Ø¹Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø³ÙŠØ±ÙØ±!");

// Ø¯Ø§Ù„Ø© Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ ÙˆØ§Ù„Ø®Ø±ÙˆØ¬
function logLoginLogout(type) {
  const logFile = 'login_logout_log.txt';
  const now = new Date().toISOString();
  fs.appendFileSync(logFile, `${type},${now}\n`, 'utf8');
}

// ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„
logLoginLogout('login');

// Ù†Ø­Ø§ÙˆÙ„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¬Ù„Ø³Ø© Ù…Ù† Ù…Ù„Ù
let stringSession = new StringSession("");

if (fs.existsSync("session.txt")) {
  const savedSession = fs.readFileSync("session.txt", "utf8");
  stringSession = new StringSession(savedSession.trim());
}

// ØªØ¹Ø±ÙŠÙ Ø§Ù„ÙƒØ§Ø¦Ù† client ÙÙŠ Ø§Ù„Ù†Ø·Ø§Ù‚ Ø§Ù„Ø¹Ø§Ù…
const client = new TelegramClient(stringSession, apiId, apiHash, {
  connectionRetries: 5,
});

(async () => {
  console.log("ğŸ“² Ø¨Ø¯Ø¡ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨ØªÙ„ÙŠØ¬Ø±Ø§Ù…...");

  // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¹Ù†Ø¯ Ø§Ù„Ø­Ø§Ø¬Ø© ÙÙ‚Ø·
  await client.start({
    phoneNumber: async () => PHONE_NUMBER,
    password: async () => PASSWORD,
    phoneCode: async () => await input.text("Ø£Ø¯Ø®Ù„ ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù…:"),
    onError: (err) => console.log("âŒ Ø®Ø·Ø£:", err),
  });

  console.log("âœ… ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„!");
  const sessionString = client.session.save();

  // Ø­ÙØ¸ Ø§Ù„Ø¬Ù„Ø³Ø© Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ØªØ§Ù„ÙŠ
  fs.writeFileSync("session.txt", sessionString);
  console.log("ğŸ’¾ ØªÙ… Ø­ÙØ¸ Ø§Ù„Ø¬Ù„Ø³Ø© ÙÙŠ session.txt");

  await client.sendMessage("me", { message: "ğŸš€ Ø¨ÙˆØª Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ø´ØºØ§Ù„!" });
})();

// Ø¯Ø§Ù„Ø© ØªØ£Ø®ÙŠØ± Ø¨Ø³ÙŠØ·Ø©
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

const PORT = process.env.PORT || 3100;
http.createServer((req, res) => {
  const url = new URL(req.url, `http://${req.headers.host}`);

  if (url.pathname === '/search-token' && req.method === 'GET') {
    const token = url.searchParams.get('token');

    if (!token) {
      res.writeHead(400, { 'Content-Type': 'text/plain; charset=utf-8' });
      res.end('âŒ ÙŠØ±Ø¬Ù‰ ØªÙ‚Ø¯ÙŠÙ… Ø§Ø³Ù… Ø§Ù„ØªÙˆÙƒÙ† ÙÙŠ Ø§Ù„Ø·Ù„Ø¨.');
      return;
    }

    const filePath = `${CONFIG_DIR}/${token}.txt`;

    if (fs.existsSync(filePath)) {
      const fileContent = fs.readFileSync(filePath, 'utf8');
      res.writeHead(200, { 'Content-Type': 'text/plain; charset=utf-8' });
      res.end(fileContent);
    } else {
      res.writeHead(404, { 'Content-Type': 'text/plain; charset=utf-8' });
      res.end('âŒ Ø§Ù„Ù…Ù„Ù ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯.');
    }
  } else if (url.pathname === '/' && req.method === 'GET') {
    // ØµÙØ­Ø© Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ØªÙˆÙƒÙ†
    fs.readdir(CONFIG_DIR, (err, files) => {
      if (err) {
        res.writeHead(500, { 'Content-Type': 'text/plain; charset=utf-8' });
        res.end('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…Ù„ÙØ§Øª.');
        return;
      }

      // ØªØµÙÙŠØ© Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù†Ø§Ø¬Ø­Ø© ÙÙ‚Ø·
      const successfulConfigs = files
        .filter(file => file.endsWith('.txt') && file !== 'Buy_Token.txt')
        .map(file => {
          const filePath = `${CONFIG_DIR}/${file}`;
          const content = fs.readFileSync(filePath, 'utf8');
          if (content.includes('Ù†Ø§Ø¬Ø­ âœ…ï¸')) {
            return file.replace('.txt', ''); // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø§Ù…ØªØ¯Ø§Ø¯
          }
          return null;
        })
        .filter(Boolean);

      const configList = successfulConfigs
        .map(token => `
          <li>
            ${token} 
            <form method="POST" action="/sell" style="display:inline;">
              <input type="hidden" name="token" value="${token}" />
              <button type="submit" style="padding:5px 10px; font-size:0.9em;">SELL</button>
            </form>
          </li>
        `)
        .join('');

      res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
      res.end(`
        <html>
          <head>
            <title>Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ØªÙƒÙˆÙŠÙ†</title>
          </head>
          <body style="text-align:center; font-family:Arial;">
            <h1>ğŸ” Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ØªÙƒÙˆÙŠÙ†</h1>
            <form method="GET" action="/search-token">
              <input type="text" name="token" placeholder="Ø£Ø¯Ø®Ù„ Ø§Ø³Ù… Ø§Ù„ØªÙˆÙƒÙ†" required style="padding:10px; font-size:1em;" />
              <button type="submit" style="padding:10px 20px; font-size:1em;">Ø¨Ø­Ø«</button>
            </form>
            <h2>âœ… Ø§Ù„ØªÙƒÙˆÙŠÙ†Ø§Øª Ø§Ù„Ù†Ø§Ø¬Ø­Ø©</h2>
            <ul style="list-style:none; padding:0;">${configList}</ul>
          </body>
        </html>
      `);
    });
  } else if (url.pathname === '/upload' && req.method === 'GET') {
    // ØµÙØ­Ø© Ø±ÙØ¹ Ø§Ù„Ù…Ù„ÙØ§Øª
    res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
    res.end(`
      <html>
        <head>
          <title>Ø±ÙØ¹ Ù…Ù„ÙØ§Øª Ø§Ù„ØªÙƒÙˆÙŠÙ†</title>
        </head>
        <body style="text-align:center; font-family:Arial;">
          <h1>ğŸ“¤ Ø±ÙØ¹ Ù…Ù„ÙØ§Øª Ø§Ù„ØªÙƒÙˆÙŠÙ†</h1>
          <form method="POST" action="/upload" enctype="multipart/form-data">
            <input type="file" name="configFile" required style="padding:10px; font-size:1em;" />
            <button type="submit" style="padding:10px 20px; font-size:1em;">Ø±ÙØ¹</button>
          </form>
        </body>
      </html>
    `);
  } else if (url.pathname === '/upload' && req.method === 'POST') {
    const form = new multer({ dest: 'uploads/' });
    form.single('configFile')(req, res, (err) => {
      if (err) {
        res.writeHead(500, { 'Content-Type': 'text/plain; charset=utf-8' });
        res.end('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø±ÙØ¹ Ø§Ù„Ù…Ù„Ù.');
        return;
      }

      const uploadedFile = req.file;
      if (uploadedFile) {
        res.writeHead(200, { 'Content-Type': 'text/plain; charset=utf-8' });
        res.end(`âœ… ØªÙ… Ø±ÙØ¹ Ø§Ù„Ù…Ù„Ù Ø¨Ù†Ø¬Ø§Ø­: ${uploadedFile.originalname}`);
      } else {
        res.writeHead(400, { 'Content-Type': 'text/plain; charset=utf-8' });
        res.end('âŒ ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ù…Ù„Ù Ù„Ø±ÙØ¹Ù‡.');
      }
    });
  } else if (url.pathname === '/files' && req.method === 'GET') {
    // ØµÙØ­Ø© Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø±ÙÙˆØ¹Ø©
    fs.readdir(CONFIG_DIR, (err, files) => {
      if (err) {
        res.writeHead(500, { 'Content-Type': 'text/plain; charset=utf-8' });
        res.end('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…Ù„ÙØ§Øª.');
        return;
      }

      const fileLinks = files
        .filter(file => file.endsWith('.txt'))
        .map(file => `<li><a href="/files/${file}" target="_blank">${file}</a></li>`)
        .join('');

      res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
      res.end(`
        <html>
          <head>
            <title>Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø±ÙÙˆØ¹Ø©</title>
          </head>
          <body style="text-align:center; font-family:Arial;">
            <h1>ğŸ“‚ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø±ÙÙˆØ¹Ø©</h1>
            <ul style="list-style:none; padding:0;">${fileLinks}</ul>
            <a href="/upload" style="display:block; margin-top:20px;">ğŸ”™ Ø§Ù„Ø¹ÙˆØ¯Ø© Ø¥Ù„Ù‰ ØµÙØ­Ø© Ø§Ù„Ø±ÙØ¹</a>
          </body>
        </html>
      `);
    });
  } else if (url.pathname.startsWith('/files/') && req.method === 'GET') {
    // Ø¹Ø±Ø¶ Ù…Ø­ØªÙˆÙ‰ Ù…Ù„Ù Ù…Ø¹ÙŠÙ†
    const fileName = url.pathname.replace('/files/', '');
    const filePath = `${CONFIG_DIR}/${fileName}`;

    if (fs.existsSync(filePath)) {
      const fileContent = fs.readFileSync(filePath, 'utf8');
      res.writeHead(200, { 'Content-Type': 'text/plain; charset=utf-8' });
      res.end(fileContent);
    } else {
      res.writeHead(404, { 'Content-Type': 'text/plain; charset=utf-8' });
      res.end('âŒ Ø§Ù„Ù…Ù„Ù ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯.');
    }
  } else if (url.pathname === '/sell' && req.method === 'POST') {
    // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø·Ù„Ø¨ SELL
    let body = '';
    req.on('data', chunk => {
      body += chunk.toString();
    });
    req.on('end', async () => {
      const params = new URLSearchParams(body);
      const token = params.get('token');

      if (token) {
        const sellCommand = `/sell ${token} 100%`;
        fs.appendFileSync("Sell_Token.txt", `${sellCommand}\n`, 'utf8');

        // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø£Ù…Ø± Ø¥Ù„Ù‰ Ø§Ù„Ø¨ÙˆØª
        try {
          await client.sendMessage("@GMGN_sol_bot", { message: sellCommand });
          res.writeHead(200, { 'Content-Type': 'text/plain; charset=utf-8' });
          res.end(`âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø£Ù…Ø± SELL Ù„Ù„ØªÙƒÙˆÙŠÙ†: ${token}`);
        } catch (err) {
          res.writeHead(500, { 'Content-Type': 'text/plain; charset=utf-8' });
          res.end(`âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø£Ù…Ø± SELL: ${err.message}`);
        }
      } else {
        res.writeHead(400, { 'Content-Type': 'text/plain; charset=utf-8' });
        res.end('âŒ Ù„Ù… ÙŠØªÙ… ØªÙ‚Ø¯ÙŠÙ… Ø§Ø³Ù… Ø§Ù„ØªÙˆÙƒÙ†.');
      }
    });
  } else {
    // ØµÙØ­Ø© Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
    res.writeHead(200, { "Content-Type": "text/html; charset=utf-8" });
    res.end(`
      <div style='text-align:center;'>
        <div style='font-size:2em;'>ğŸš€ Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø§Ù„Ø¢Ù† 24 Ø³Ø§Ø¹Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø³ÙŠØ±ÙØ±!</div>
      </div>
    `);
  }
}).listen(PORT, () => {
  console.log(`ğŸŒ HTTP Server running on port ${PORT}`);
});

const KEEP_ALIVE_URL = "https://fdfd.onrender.com/";
setInterval(() => {
  https.get(KEEP_ALIVE_URL, (res) => {
    console.log(`ğŸ”„ Keep Alive Ping: ${KEEP_ALIVE_URL} - Status: ${res.statusCode}`);
  }).on("error", (e) => {
    console.error(`âŒ Keep Alive Error: ${e.message}`);
  });
}, 10 * 60 * 1000); // ÙƒÙ„ 10 Ø¯Ù‚Ø§Ø¦Ù‚

// ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬ Ø¹Ù†Ø¯ Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©
process.on('exit', () => {
  logLoginLogout('logout');
});
process.on('SIGINT', () => {
  logLoginLogout('logout');
  process.exit();
});

// ØªØ¹Ø¯ÙŠÙ„ Ù„Ø¬Ø¹Ù„ Ø§Ù„Ø¨Ø­Ø« ÙŠØ´Ù…Ù„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„ÙˆØ§Ø±Ø¯Ø©
const tokenData = {}; // ØªØ®Ø²ÙŠÙ† Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªÙˆÙƒÙ†Ø§Øª Ù…Ø¤Ù‚ØªÙ‹Ø§

client.addEventHandler(async (update) => {
  try {
    if (update.message && typeof update.message.message === "string") {
      const msg = update.message;
      const text = msg.message;

      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø§Ù„ØªÙŠ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ "COUNTS: X"
      const countMatch = text.match(/COUNTS:\s*(\d+)/i);
      const tokenMatch = text.match(/ca:\s*([\w]+)/i);

      if (countMatch && tokenMatch) {
        const count = parseInt(countMatch[1], 10);
        const token = tokenMatch[1];
        const now = Date.now();

        // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰ "COUNTS: 1"
        if (count === 1) {
          tokenData[token] = [{ count, timestamp: now }];
          fs.writeFileSync(`${CONFIG_DIR}/${token}.txt`, `${token} : Counts: 1\n`, 'utf8');
        } else if (tokenData[token]) {
          // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø±Ø³Ø§Ù„Ø© ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ "COUNTS: X" Ø­ÙŠØ« X > 1
          const previous = tokenData[token][tokenData[token].length - 1];
          const timeDiff = Math.round((now - previous.timestamp) / 1000); // Ø§Ù„ÙØ±Ù‚ Ø¨Ø§Ù„Ø«ÙˆØ§Ù†ÙŠ

          // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙˆØ­ÙØ¸Ù‡Ø§ ÙÙŠ Ø§Ù„Ù…Ù„Ù
          tokenData[token].push({ count, timestamp: now });
          fs.appendFileSync(
            `${CONFIG_DIR}/${token}.txt`,
            `Counts: ${count} To Counts: ${previous.count} = ${timeDiff}second\n`,
            'utf8'
          );

          // Ø§Ù„ØªØ­Ù‚Ù‚ Ø¹Ù†Ø¯ Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ 10 ÙØªØ±Ø§Øª
          if (tokenData[token].length === 10) {
            const timeDiffs = tokenData[token].slice(1).map((entry, index) => {
              return Math.round((entry.timestamp - tokenData[token][index].timestamp) / 1000);
            });

            const isSuccessful = timeDiffs.every(diff => diff >= 12 && diff <= 5000);

            if (isSuccessful) {
              fs.appendFileSync(`${CONFIG_DIR}/${token}.txt`, `Ù†Ø§Ø¬Ø­ âœ…ï¸\n`, 'utf8');
              const buyCommand = `/buy ${token} 0.5`;
              fs.appendFileSync("Buy_Token.txt", `${buyCommand}\n`, 'utf8');

              // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø£Ù…Ø± Ø¥Ù„Ù‰ Ø§Ù„Ø¨ÙˆØª
              await client.sendMessage("@GMGN_sol_bot", { message: buyCommand });
            } else {
              fs.appendFileSync(`${CONFIG_DIR}/${token}.txt`, `ÙØ§Ø´Ù„ âŒï¸\n`, 'utf8');
            }
          }
        }
      }
    }
  } catch (err) {
    console.error("âŒ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªÙˆØ¬ÙŠÙ‡:", err.message);
  }
});

// ÙˆØ¸ÙŠÙØ© Ù„Ø­Ø°Ù Ù…Ù„ÙØ§Øª Ø§Ù„ØªÙƒÙˆÙŠÙ† Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©
const DELETE_AFTER_HOURS = 48; // Ø¹Ø¯Ø¯ Ø§Ù„Ø³Ø§Ø¹Ø§Øª Ù‚Ø¨Ù„ Ø§Ù„Ø­Ø°Ù

function deleteOldConfigFiles() {
  const now = Date.now();
  const deleteThreshold = DELETE_AFTER_HOURS * 60 * 60 * 1000; // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø³Ø§Ø¹Ø§Øª Ø¥Ù„Ù‰ Ù…ÙŠÙ„ÙŠ Ø«Ø§Ù†ÙŠØ©

  fs.readdir(CONFIG_DIR, (err, files) => {
    if (err) {
      console.error("âŒ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…Ù„ÙØ§Øª:", err.message);
      return;
    }

    files.forEach((file) => {
      if (file.endsWith(".txt") && file !== "Buy_Token.txt") { // Ø§Ø³ØªÙ‡Ø¯Ø§Ù Ù…Ù„ÙØ§Øª Ø§Ù„ØªÙƒÙˆÙŠÙ† ÙÙ‚Ø·
        const filePath = `${CONFIG_DIR}/${file}`;
        fs.stat(filePath, (err, stats) => {
          if (err) {
            console.error(`âŒ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ÙØ­Øµ Ø§Ù„Ù…Ù„Ù ${file}:`, err.message);
            return;
          }

          const fileAge = now - stats.mtimeMs; // Ø­Ø³Ø§Ø¨ Ø¹Ù…Ø± Ø§Ù„Ù…Ù„Ù
          if (fileAge > deleteThreshold) {
            fs.unlink(filePath, (err) => {
              if (err) {
                console.error('Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø­Ø°Ù Ø§Ù„Ù…Ù„Ù:', file, err.message);
              } else {
                console.log('ØªÙ… Ø­Ø°Ù Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù‚Ø¯ÙŠÙ…:', file);
              }
            });
          }
        });
      }
    });
  });
}

// ØªØ´ØºÙŠÙ„ ÙˆØ¸ÙŠÙØ© Ø§Ù„Ø­Ø°Ù ÙƒÙ„ Ø³Ø§Ø¹Ø©
setInterval(function() {
  deleteOldConfigFiles();
}, 60 * 60 * 1000);

// Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¬Ù„Ø¯ configs Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ù‹Ø§
const CONFIG_DIR = `${__dirname}/configs`;
if (!fs.existsSync(CONFIG_DIR)) {
  fs.mkdirSync(CONFIG_DIR);
}

// Ù†Ù‚Ù„ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ø¥Ù„Ù‰ Ù…Ø¬Ù„Ø¯ configs
fs.readdir(__dirname, (err, files) => {
  if (err) {
    console.error("âŒ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…Ù„ÙØ§Øª:", err.message);
    return;
  }

  files.forEach((file) => {
    if (file.endsWith(".txt") && file !== "Buy_Token.txt") {
      const oldPath = `${__dirname}/${file}`;
      const newPath = `${CONFIG_DIR}/${file}`;

      fs.rename(oldPath, newPath, (err) => {
        if (err) {
          console.error(`âŒ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù†Ù‚Ù„ Ø§Ù„Ù…Ù„Ù ${file}:`, err.message);
        } else {
          console.log(`âœ… ØªÙ… Ù†Ù‚Ù„ Ø§Ù„Ù…Ù„Ù ${file} Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø¬Ù„Ø¯ configs.`);
        }
      });
    }
  });
});
