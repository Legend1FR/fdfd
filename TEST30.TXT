const { TelegramClient } = require("telegram");
const { StringSession } = require("telegram/sessions");
const fs = require("fs");
const input = require("input");
const http = require("http");
const https = require("https");

const { performance } = require('perf_hooks');
const puppeteer = require('puppeteer');
// قائمة التوكنات المراقبة
const trackedTokens = {};

// متصفح مشترك لجميع التوكنات لتوفير الذاكرة
let sharedBrowser = null;

// حد أقصى لعدد التوكنات المراقبة في نفس الوقت
const MAX_TRACKED_TOKENS = 100;

// ملف حفظ التوكنات المتتبعة
const trackedTokensFile = 'tracked_tokens.json';

// قائمة التوكنات التي تم إرسالها لتجنب الإرسال المكرر
const sentTokens = new Set();
const sentTokensFile = 'sent_tokens.txt';

// مخزن مؤقت لسجلات وقت التنفيذ
const executionLogsBuffer = [];

// تحميل التوكنات المرسلة من الملف
function loadSentTokens() {
  try {
    if (fs.existsSync(sentTokensFile)) {
      const data = fs.readFileSync(sentTokensFile, 'utf8');
      const tokens = data.split('\n').filter(token => token.trim());
      tokens.forEach(token => sentTokens.add(token.trim()));
      console.log(`📨 تم تحميل ${tokens.length} توكن مرسل من الملف`);
    }
  } catch (error) {
    console.error('❌ خطأ في تحميل التوكنات المرسلة:', error.message);
  }
}

// إنشاء المتصفح المشترك
async function getSharedBrowser() {
  if (sharedBrowser && sharedBrowser.isConnected()) {
    return sharedBrowser;
  }

  try {
    console.log('🔄 جاري إنشاء متصفح مشترك جديد...');
    const launchOptions = {
      headless: true, // تغيير إلى false لتجنب اكتشاف البوت
      args: [
        '--no-sandbox', 
        '--disable-setuid-sandbox', 
        '--disable-blink-features=AutomationControlled',
        '--disable-web-security',
        '--disable-dev-shm-usage',
        '--no-first-run',
        '--disable-default-apps',
        '--disable-extensions',
        '--disable-infobars',
        '--disable-features=VizDisplayCompositor',
        '--window-size=1366,768',
        '--start-maximized',
        '--disable-background-timer-throttling',
        '--disable-backgrounding-occluded-windows',
        '--disable-renderer-backgrounding'
      ]
    };

    // تحديد مسارات Chrome المتعددة للـ Windows
    const chromePaths = [
      'C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe',
      'C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe',
      process.env.PROGRAMFILES + '\\Google\\Chrome\\Application\\chrome.exe',
      process.env['PROGRAMFILES(X86)'] + '\\Google\\Chrome\\Application\\chrome.exe',
      process.env.PUPPETEER_EXECUTABLE_PATH
    ].filter(Boolean);

    let browserLaunched = false;
    
    // محاولة استخدام Chrome المثبت على النظام
    for (const chromePath of chromePaths) {
      try {
        if (fs.existsSync(chromePath)) {
          launchOptions.executablePath = chromePath;
          sharedBrowser = await puppeteer.launch(launchOptions);
          browserLaunched = true;
          console.log(`🌐 تم إطلاق المتصفح المشترك الجديد من: ${chromePath}`);
          break;
        }
      } catch (err) {
        console.log(`⚠️ فشل في إطلاق Chrome من ${chromePath}: ${err.message}`);
      }
    }

    // محاولة استخدام Chrome المحمّل بواسطة Puppeteer
    if (!browserLaunched) {
      try {
        delete launchOptions.executablePath;
        sharedBrowser = await puppeteer.launch(launchOptions);
        browserLaunched = true;
        console.log(`🌐 تم إطلاق المتصفح المشترك الجديد بواسطة Puppeteer`);
      } catch (err) {
        console.error(`❌ فشل في إطلاق المتصفح المشترك: ${err.message}`);
        throw err;
      }
    }

    return sharedBrowser;
  } catch (error) {
    console.error('❌ خطأ في إنشاء المتصفح المشترك:', error.message);
    sharedBrowser = null;
    throw error;
  }
}

// إغلاق المتصفح المشترك بأمان
async function closeSharedBrowser() {
  if (sharedBrowser) {
    try {
      console.log('🔄 جاري إغلاق المتصفح المشترك...');
      
      // إغلاق جميع الصفحات أولاً مع مهلة زمنية
      const pages = await Promise.race([
        sharedBrowser.pages(),
        new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout getting pages')), 3000))
      ]);
      
      for (const page of pages) {
        try {
          await Promise.race([
            page.close(),
            new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout closing page')), 2000))
          ]);
        } catch (err) {
          // تجاهل أخطاء إغلاق الصفحات
        }
      }
      
      // إغلاق المتصفح مع مهلة زمنية
      await Promise.race([
        sharedBrowser.close(),
        new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout closing browser')), 5000))
      ]);
      
      console.log('✅ تم إغلاق المتصفح المشترك بنجاح');
      sharedBrowser = null;
    } catch (error) {
      console.error('⚠️ خطأ في إغلاق المتصفح:', error.message);
      // في حالة فشل الإغلاق العادي، استخدم الإنهاء القسري
      try {
        const process = sharedBrowser.process();
        if (process && !process.killed) {
          process.kill('SIGKILL');
          console.log('⚡ تم إنهاء عملية المتصفح قسرياً');
        }
      } catch (killError) {
        console.error('❌ فشل في إنهاء عملية المتصفح:', killError.message);
      }
      sharedBrowser = null;
    }
  }
}

// حفظ التوكنات المتتبعة إلى ملف
function saveTrackedTokens() {
  try {
    const tokensToSave = {};
    Object.keys(trackedTokens).forEach(token => {
      const t = trackedTokens[token];
      tokensToSave[token] = {
        token: t.token,
        startTime: t.startTime,
        firstPrice: t.firstPrice,
        lastPrice: t.lastPrice,
        maxIncrease: t.maxIncrease,
        reached50: t.reached50,
        stopped: t.stopped,
        browserFailed: t.browserFailed,
        manualMode: t.manualMode,
        rugcheckStatus: t.rugcheckStatus, // إضافة حفظ حالة rugcheck
        lowLiquidity: t.lowLiquidity, // إضافة حفظ حالة السيولة
        solValue: t.solValue, // إضافة حفظ قيمة SOL
        // إضافة حفظ الخصائص الجديدة
        previousHighPrice: t.previousHighPrice,
        currentHighPrice: t.currentHighPrice,
        lastRiseTime: t.lastRiseTime,
        rapidRiseAchieved: t.rapidRiseAchieved,
        priceRiseHistory: t.priceRiseHistory || [] // تأكد من حفظ المصفوفة
        // لا نحفظ page لأنها كائنات غير قابلة للتسلسل
      };
    });
    fs.writeFileSync(trackedTokensFile, JSON.stringify(tokensToSave, null, 2), 'utf8');
  } catch (error) {
    console.error('❌ خطأ في حفظ التوكنات المتتبعة:', error.message);
  }
}

// تحميل التوكنات المتتبعة من ملف
function loadTrackedTokens() {
  try {
    if (fs.existsSync(trackedTokensFile)) {
      const savedTokens = JSON.parse(fs.readFileSync(trackedTokensFile, 'utf8'));
      Object.keys(savedTokens).forEach(token => {
        const savedToken = savedTokens[token];
        trackedTokens[token] = {
          ...savedToken,
          startTime: new Date(savedToken.startTime), // تحويل التاريخ من string إلى Date
          page: null,
          rugcheckStatus: savedToken.rugcheckStatus || null, // تحميل حالة rugcheck أو تعيين null إذا لم تكن موجودة
          lowLiquidity: savedToken.lowLiquidity || null, // تحميل حالة السيولة
          solValue: savedToken.solValue || null, // تحميل قيمة SOL
          // التأكد من وجود جميع الخصائص الجديدة
          previousHighPrice: savedToken.previousHighPrice || null,
          currentHighPrice: savedToken.currentHighPrice || null,
          lastRiseTime: savedToken.lastRiseTime ? new Date(savedToken.lastRiseTime) : null,
          rapidRiseAchieved: savedToken.rapidRiseAchieved || false,
          priceRiseHistory: savedToken.priceRiseHistory || [] // تأكد من وجود المصفوفة
        };
      });
      console.log(`📊 تم تحميل ${Object.keys(savedTokens).length} توكن من الملف المحفوظ`);
      
      // إعادة بدء المراقبة للتوكنات التي لم تتوقف
      Object.keys(trackedTokens).forEach(token => {
        const t = trackedTokens[token];
        if (!t.stopped && !t.browserFailed) {
          console.log(`🔄 إعادة بدء مراقبة التوكن: ${token}`);
          startPuppeteerTracking(token, t.startTime).catch(err => {
            console.error(`[${token}] خطأ في إعادة بدء المراقبة: ${err.message}`);
            startManualTracking(token);
          });
        }
      });
    }
  } catch (error) {
    console.error('❌ خطأ في تحميل التوكنات المتتبعة:', error.message);
  }
}

// التحقق من حالة التوكن على rugcheck.xyz مع إعادة المحاولة
async function checkTokenSafety(token) {
  const maxRetries = 5; // عدد المحاولات القصوى
  let attempt = 0;
  
  while (attempt < maxRetries) {
    attempt++;
    let page = null;
    
    try {
      console.log(`[${token}] 🔍 محاولة ${attempt}/${maxRetries} للتحقق من حالة التوكن على rugcheck.xyz...`);
      
      const browser = await getSharedBrowser();
      page = await browser.newPage();
      
      // إعداد user-agent حقيقي
      await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36');
      
      // إزالة متغيرات تدل على الأتمتة
      await page.evaluateOnNewDocument(() => {
        Object.defineProperty(navigator, 'webdriver', { get: () => undefined });
        Object.defineProperty(navigator, 'plugins', { get: () => [1, 2, 3, 4, 5] });
        Object.defineProperty(navigator, 'languages', { get: () => ['en-US', 'en'] });
      });
      
      const rugcheckUrl = `https://rugcheck.xyz/tokens/${token}`;
      
      // التنقل إلى صفحة rugcheck مع timeout أطول
      await page.goto(rugcheckUrl, { 
        waitUntil: 'networkidle0', // انتظار حتى لا توجد طلبات شبكة لمدة 500ms
        timeout: 45000 
      });
      
      // انتظار تحميل المحتوى مع فترة أطول
      await new Promise(resolve => setTimeout(resolve, 8000));
      
      // البحث عن حالة التوكن
      let tokenStatus = null;
      
      try {
        // طرق متعددة للبحث عن الحالة
        
        // 1. البحث في النص الكامل للصفحة
        const pageText = await page.evaluate(() => document.body.innerText.toLowerCase());
        console.log(`[${token}] عينة من نص الصفحة: ${pageText.slice(0, 500)}...`);
        
        // البحث عن كلمات مفتاحية محددة وواضحة
        if (pageText.includes('high risk') || pageText.includes('dangerous') || pageText.includes('rug') || 
            pageText.includes('scam') || pageText.includes('malicious') || pageText.includes('honeypot')) {
          tokenStatus = 'DANGER';
          console.log(`[${token}] ⚠️ تم العثور على مؤشرات خطر في النص`);
        } else if (pageText.includes('medium risk') || pageText.includes('warning') || pageText.includes('caution') ||
                   pageText.includes('moderate') || pageText.includes('yellow')) {
          tokenStatus = 'WARNING';
          console.log(`[${token}] ⚠️ تم العثور على مؤشرات تحذير في النص`);
        } else if (pageText.includes('low risk') || pageText.includes('safe') || pageText.includes('good') ||
                   pageText.includes('green') || pageText.includes('legitimate')) {
          tokenStatus = 'GOOD';
          console.log(`[${token}] ✅ تم العثور على مؤشرات أمان في النص`);
        }
        
        // 2. البحث في العناصر بالألوان والأكلاس
        if (!tokenStatus) {
          console.log(`[${token}] البحث في العناصر بالألوان والكلاسات...`);
          
          // البحث عن عناصر حمراء (خطر)
          const redElements = await page.$$eval('*', elements => {
            return elements.filter(el => {
              const style = window.getComputedStyle(el);
              const text = el.textContent.toLowerCase();
              const className = el.className.toLowerCase();
              
              return (style.color.includes('rgb(255') || style.color.includes('red') ||
                     style.backgroundColor.includes('rgb(255') || style.backgroundColor.includes('red') ||
                     className.includes('danger') || className.includes('red') || className.includes('high') ||
                     text.includes('danger') || text.includes('high risk') || text.includes('rug'));
            }).map(el => el.textContent.trim()).slice(0, 3);
          });
          
          if (redElements.length > 0) {
            tokenStatus = 'DANGER';
            console.log(`[${token}] ⚠️ عناصر حمراء موجودة: ${redElements.join(', ')}`);
          }
        }
        
        // 3. البحث عن عناصر صفراء/برتقالية (تحذير)
        if (!tokenStatus) {
          const yellowElements = await page.$$eval('*', elements => {
            return elements.filter(el => {
              const style = window.getComputedStyle(el);
              const text = el.textContent.toLowerCase();
              const className = el.className.toLowerCase();
              
              return (style.color.includes('orange') || style.color.includes('yellow') ||
                     style.backgroundColor.includes('orange') || style.backgroundColor.includes('yellow') ||
                     className.includes('warning') || className.includes('yellow') || className.includes('medium') ||
                     text.includes('warning') || text.includes('medium risk') || text.includes('caution'));
            }).map(el => el.textContent.trim()).slice(0, 3);
          });
          
          if (yellowElements.length > 0) {
            tokenStatus = 'WARNING';
            console.log(`[${token}] ⚠️ عناصر تحذيرية موجودة: ${yellowElements.join(', ')}`);
          }
        }
        
        // 4. البحث عن عناصر خضراء (آمن)
        if (!tokenStatus) {
          const greenElements = await page.$$eval('*', elements => {
            return elements.filter(el => {
              const style = window.getComputedStyle(el);
              const text = el.textContent.toLowerCase();
              const className = el.className.toLowerCase();
              
              return (style.color.includes('green') || style.color.includes('rgb(0') ||
                     style.backgroundColor.includes('green') || style.backgroundColor.includes('rgb(0') ||
                     className.includes('good') || className.includes('green') || className.includes('safe') ||
                     text.includes('good') || text.includes('safe') || text.includes('low risk'));
            }).map(el => el.textContent.trim()).slice(0, 3);
          });
          
          if (greenElements.length > 0) {
            tokenStatus = 'GOOD';
            console.log(`[${token}] ✅ عناصر أمان موجودة: ${greenElements.join(', ')}`);
          }
        }
        
        // 5. البحث في أتريبيوت data وعناوين العناصر
        if (!tokenStatus) {
          const dataAttributes = await page.$$eval('*[data-status], *[data-risk], *[data-level], *[title*="risk"], *[title*="safe"], *[title*="danger"]', elements => {
            return elements.map(el => ({
              tag: el.tagName,
              dataStatus: el.getAttribute('data-status'),
              dataRisk: el.getAttribute('data-risk'),
              dataLevel: el.getAttribute('data-level'),
              title: el.getAttribute('title'),
              text: el.textContent.trim()
            }));
          });
          
          for (const attr of dataAttributes) {
            const values = Object.values(attr).join(' ').toLowerCase();
            if (values.includes('danger') || values.includes('high') || values.includes('rug')) {
              tokenStatus = 'DANGER';
              console.log(`[${token}] ⚠️ مؤشر خطر في الأتريبيوت: ${JSON.stringify(attr)}`);
              break;
            } else if (values.includes('warning') || values.includes('medium') || values.includes('caution')) {
              tokenStatus = 'WARNING';
              console.log(`[${token}] ⚠️ مؤشر تحذير في الأتريبيوت: ${JSON.stringify(attr)}`);
              break;
            } else if (values.includes('good') || values.includes('safe') || values.includes('low')) {
              tokenStatus = 'GOOD';
              console.log(`[${token}] ✅ مؤشر أمان في الأتريبيوت: ${JSON.stringify(attr)}`);
              break;
            }
          }
        }
        
      } catch (evaluateError) {
        console.log(`[${token}] خطأ في تقييم محتوى الصفحة: ${evaluateError.message}`);
      }
      
      // إغلاق الصفحة
      await page.close();
      
      if (tokenStatus) {
        console.log(`[${token}] ✅ تم العثور على حالة التوكن في المحاولة ${attempt}: ${tokenStatus}`);
        return tokenStatus;
      } else {
        console.log(`[${token}] ⚠️ لم يتم العثور على حالة واضحة في المحاولة ${attempt}`);
        if (attempt < maxRetries) {
          console.log(`[${token}] ⏳ انتظار 3 ثوانٍ قبل المحاولة التالية...`);
          await new Promise(resolve => setTimeout(resolve, 3000));
        }
      }
      
    } catch (error) {
      console.error(`[${token}] ❌ خطأ في المحاولة ${attempt}: ${error.message}`);
      if (page && !page.isClosed()) {
        await page.close();
      }
      
      if (attempt < maxRetries) {
        console.log(`[${token}] ⏳ انتظار 5 ثوانٍ قبل إعادة المحاولة...`);
        await new Promise(resolve => setTimeout(resolve, 5000));
      }
    }
  }
  
  // إذا فشلت جميع المحاولات، اعتبر التوكن آمن كقيمة افتراضية
  console.log(`[${token}] ⚠️ فشل في تحديد الحالة بعد ${maxRetries} محاولات - سيتم اعتباره آمن كقيمة افتراضية`);
  return 'GOOD'; // قيمة افتراضية آمنة
}

// بدء مراقبة توكن جديد (مع إمكانية العمل بدون puppeteer)
async function startTrackingToken(token, rugcheckStatus = null, solValue = null) {
  if (trackedTokens[token]) {
    // إذا كان التوكن موجود، فقط قم بتحديث حالة rugcheck و solValue
    if (rugcheckStatus !== null) {
      trackedTokens[token].rugcheckStatus = rugcheckStatus;
    }
    if (solValue !== null) {
      trackedTokens[token].solValue = solValue;
    }
    saveTrackedTokens();
    return;
  }
  
  // التحقق من الحد الأقصى للتوكنات المراقبة
  const activeTokensCount = Object.keys(trackedTokens).filter(t => !trackedTokens[t].stopped).length;
  if (activeTokensCount >= MAX_TRACKED_TOKENS) {
    console.log(`⚠️ تم الوصول للحد الأقصى من التوكنات المراقبة (${MAX_TRACKED_TOKENS}). تخطي التوكن: ${token}`);
    return;
  }
  
  // إضافة التوكن للمراقبة فوراً حتى لو فشل المتصفح
  const startTime = new Date();
  trackedTokens[token] = {
    token,
    startTime,
    firstPrice: null,
    lastPrice: null,
    maxIncrease: 0,
    reached50: false,
    stopped: false,
    page: null,
    browserFailed: false,
    manualMode: false, // وضع يدوي بدون puppeteer
    rugcheckStatus: rugcheckStatus, // حالة التحقق من rugcheck.xyz
    lowLiquidity: null, // حالة السيولة: true = منخفضة، false = طبيعية، null = غير محققة
    solValue: solValue, // قيمة SOL المستخرجة من الرسالة
    // New feature: Price rise comparison
    previousHighPrice: null,
    currentHighPrice: null,
    lastRiseTime: null,
    rapidRiseAchieved: false,
    priceRiseHistory: [] // Array to store price rise events with timestamps
  };

  // حفظ التوكن الجديد
  saveTrackedTokens();
  
  console.log(`[${token}] تم إضافة التوكن للمراقبة وحفظه في الملف`);

  // محاولة استخدام puppeteer، وإذا فشل استخدم وضع يدوي
  try {
    await startPuppeteerTracking(token, startTime);
  } catch (error) {
    console.error(`[${token}] فشل Puppeteer، سيتم التبديل للوضع اليدوي: ${error.message}`);
    startManualTracking(token);
  }
}

// مراقبة بـ Puppeteer
async function startPuppeteerTracking(token, startTime) {

  const url = `https://gmgn.ai/sol/token/${token}`;
  // التحقق من وجود أول سعر محفوظ مسبقاً
  let firstPrice = (trackedTokens[token] && trackedTokens[token].firstPrice && typeof trackedTokens[token].firstPrice === 'number') 
                   ? trackedTokens[token].firstPrice 
                   : null;
  let lastPrice = null;
  let maxIncrease = 0;
  let reached50 = false;
  let stopped = false;

  let browser;
  let page;
  
  try {
    // استخدام المتصفح المشترك مع إعادة المحاولة في حالة الفشل
    let retryCount = 0;
    const maxRetries = 3;
    
    while (retryCount < maxRetries) {
      try {
        browser = await getSharedBrowser();
        
        // التحقق من أن المتصفح متصل ويعمل
        if (!browser.isConnected()) {
          throw new Error('المتصفح غير متصل');
        }
        
        break; // نجح في الحصول على المتصفح
      } catch (error) {
        retryCount++;
        console.log(`[${token}] محاولة ${retryCount}/${maxRetries} للحصول على المتصفح فشلت: ${error.message}`);
        
        // إذا فشل المتصفح المشترك، أعد إنشاءه
        if (sharedBrowser) {
          try {
            await closeSharedBrowser();
          } catch (closeError) {
            console.log(`[${token}] خطأ في إغلاق المتصفح المشترك: ${closeError.message}`);
          }
          sharedBrowser = null;
        }
        
        if (retryCount >= maxRetries) {
          console.error(`[${token}] فشل في الحصول على المتصفح بعد ${maxRetries} محاولات`);
          // التبديل للوضع اليدوي
          startManualTracking(token);
          return;
        }
        
        // انتظار قبل إعادة المحاولة
        await new Promise(r => setTimeout(r, 2000));
      }
    }
    
    page = await browser.newPage();
    
    // إعداد معالجات الأخطاء للصفحة
    page.on('error', (error) => {
      console.log(`[${token}] خطأ في الصفحة: ${error.message}`);
    });
    
    page.on('pageerror', (error) => {
      console.log(`[${token}] خطأ JavaScript في الصفحة: ${error.message}`);
    });
    
    page.on('disconnect', () => {
      console.log(`[${token}] تم قطع اتصال الصفحة`);
    });
    
    // تعيين user-agent حقيقي
    await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36');
    
    // إزالة متغيرات تدل على الأتمتة
    await page.evaluateOnNewDocument(() => {
      Object.defineProperty(navigator, 'webdriver', { get: () => undefined });
      Object.defineProperty(navigator, 'plugins', { get: () => [1, 2, 3, 4, 5] });
      Object.defineProperty(navigator, 'languages', { get: () => ['en-US', 'en'] });
    });
    
    // محاولة التنقل مع إعادة المحاولة في حالة الفشل
    let navigationAttempts = 0;
    const maxNavigationAttempts = 3;
    let navigationSuccessful = false;
    
    while (navigationAttempts < maxNavigationAttempts && !navigationSuccessful) {
      try {
        navigationAttempts++;
        console.log(`[${token}] محاولة التنقل ${navigationAttempts}/${maxNavigationAttempts} إلى: ${url}`);
        
        // إضافة timeout للتنقل مع Promise.race
        await Promise.race([
          page.goto(url, { 
            waitUntil: 'domcontentloaded', 
            timeout: 60000 // تقليل timeout إلى دقيقة واحدة
          }),
          new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Navigation timeout after 60 seconds')), 60000)
          )
        ]);
        
        // انتظار إضافي للتأكد من تحميل المحتوى
        await new Promise(resolve => setTimeout(resolve, 5000)); // تقليل إلى 5 ثواني
        navigationSuccessful = true;
        console.log(`[${token}] تم التنقل بنجاح في المحاولة ${navigationAttempts}`);
        
      } catch (navError) {
        console.log(`[${token}] فشلت محاولة التنقل ${navigationAttempts}: ${navError.message}`);
        
        if (navigationAttempts >= maxNavigationAttempts) {
          throw new Error(`فشل في التنقل بعد ${maxNavigationAttempts} محاولات: ${navError.message}`);
        }
        
        // انتظار قبل إعادة المحاولة
        await new Promise(resolve => setTimeout(resolve, 2000));
      }
    }
  } catch (error) {
    console.error(`[${token}] خطأ في إعداد المتصفح: ${error.message}`);
    if (page) await page.close();
    // التبديل للوضع اليدوي في حالة فشل إعداد المتصفح
    startManualTracking(token);
    return;
  }

  // جلب أول سعر وفحص السيولة
  async function getPrice() {
    try {
      // التحقق من أن الصفحة متصلة
      if (page.isClosed()) {
        console.log(`[${token}] الصفحة مغلقة، لا يمكن جلب السعر`);
        return null;
      }
      
      // انتظار تحميل كامل للصفحة قبل البحث عن السعر
      await new Promise(resolve => setTimeout(resolve, 5000));
      
      // فحص السيولة المنخفضة (بحث موسع)
      try {
        const bodyText = await page.evaluate(() => document.body.innerText);
        // جميع الصيغ الممكنة للتحذير
        const liquidityWarnings = [
          "this token has low liquidity",
          "low liquidity",
          "no liquidity",
          "liquidity is low",
          "insufficient liquidity",
          "not enough liquidity",
          "سيولة منخفضة",
          "لا توجد سيولة"
        ];
        let hasLowLiquidity = liquidityWarnings.some(warning => bodyText.toLowerCase().includes(warning));

        // بحث في عناصر الصفحة عن كلمة liquidity وتحذيرات
        if (!hasLowLiquidity) {
          try {
            hasLowLiquidity = await page.evaluate(() => {
              const warnings = [
                "liquidity",
                "low liquidity",
                "no liquidity",
                "insufficient liquidity",
                "not enough liquidity",
                "سيولة منخفضة",
                "لا توجد سيولة"
              ];
              // ابحث في كل العناصر عن كلمة تحذير
              return Array.from(document.querySelectorAll('*')).some(el => {
                const txt = (el.textContent || "").toLowerCase();
                return warnings.some(w => txt.includes(w));
              });
            });
          } catch {}
        }

        // تحديث معلومة السيولة في trackedTokens
        if (trackedTokens[token]) {
          const previousLiquidityStatus = trackedTokens[token].lowLiquidity;
          trackedTokens[token].lowLiquidity = hasLowLiquidity;
          
          // إذا تغيرت حالة السيولة، أظهر رسالة
          if (previousLiquidityStatus !== hasLowLiquidity) {
            if (hasLowLiquidity) {
              console.log(`[${token}] ⚠️ تم اكتشاف سيولة منخفضة للتوكن - سيتم إيقاف المراقبة`);
              // إيقاف المراقبة عند اكتشاف السيولة المنخفضة
              trackedTokens[token].stopped = true;
              trackedTokens[token].lastPrice = "تم إيقاف المراقبة - سيولة منخفضة";
              saveTrackedTokens();
              return null; // إيقاف جلب السعر
            } else {
              console.log(`[${token}] ✅ تحسنت السيولة للتوكن - استمرار المراقبة`);
            }
          }
          // إذا كانت السيولة منخفضة من البداية، أوقف المراقبة
          if (hasLowLiquidity && previousLiquidityStatus === null) {
            console.log(`[${token}] ⚠️ التوكن يحتوي على سيولة منخفضة - سيتم إيقاف المراقبة`);
            trackedTokens[token].stopped = true;
            trackedTokens[token].lastPrice = "تم إيقاف المراقبة - سيولة منخفضة";
            saveTrackedTokens();
            return null;
          }
        }
      } catch (liquidityError) {
        console.log(`[${token}] خطأ في فحص السيولة: ${liquidityError.message}`);
      }
      
      // محاولة إعادة التنقل إذا كان الإطار منفصلاً
      try {
        await page.evaluate(() => document.title); // اختبار سريع للاتصال
      } catch (frameError) {
        console.log(`[${token}] الإطار منفصل، محاولة إعادة التنقل...`);
        
        try {
          // إغلاق الصفحة الحالية وإنشاء صفحة جديدة
          await page.close();
          page = await browser.newPage();
          
          // إعدادات محسنة لتجنب اكتشاف البوت
          await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36');
          await page.setViewport({ width: 1366, height: 768 });
          
          // إضافة المزيد من إعدادات مكافحة اكتشاف البوت
          await page.evaluateOnNewDocument(() => {
            Object.defineProperty(navigator, 'webdriver', { get: () => undefined });
            Object.defineProperty(navigator, 'plugins', { get: () => [1, 2, 3, 4, 5] });
            Object.defineProperty(navigator, 'languages', { get: () => ['en-US', 'en'] });
            Object.defineProperty(navigator, 'permissions', { get: () => ({ query: () => Promise.resolve({ state: 'granted' }) }) });
          });
          
          // تأخير عشوائي قبل التنقل
          await new Promise(resolve => setTimeout(resolve, Math.random() * 3000 + 2000));
          
          await page.goto(url, { waitUntil: 'networkidle2', timeout: 60000 });
          console.log(`[${token}] تم إنشاء صفحة جديدة وإعادة التنقل بنجاح`);
          
          // انتظار إضافي بعد التنقل
          await new Promise(resolve => setTimeout(resolve, 5000));
          
        } catch (retryError) {
          console.log(`[${token}] فشل في إعادة التنقل: ${retryError.message}`);
          return null;
        }
      }
      
      // جرب أولاً السلكتور .price مع معالجة أفضل للأخطاء
      try {
        console.log(`[${token}] البحث عن selector .price...`);
        await page.waitForSelector('.price', { timeout: 30000 }); // زيادة timeout
        const priceText = await page.$eval('.price', el => el.textContent);
        console.log(`[${token}] نص السعر الخام: "${priceText}"`);
        const price = parseFloat(priceText.replace(/[^\d.eE\-+]/g, ''));
        if (!isNaN(price) && price > 0) {
          console.log(`[${token}] تم جلب السعر من .price:`, price);
          return price;
        }
      } catch (e) {
        console.log(`[${token}] لم يتم العثور على .price أو حدث خطأ:`, e.message);
      }
    } catch (e) {
      console.log(`[${token}] خطأ عام في جلب السعر:`, e.message);
    }
    
    // محاولة البحث عن selectors أخرى شائعة للأسعار
    console.log(`[${token}] البحث عن السعر باستخدام selectors بديلة...`);
    const priceSelectors = [
      '[data-testid="price"]',
      '.token-price', 
      '.current-price',
      '.price-value',
      '[class*="price"]',
      '[id*="price"]',
      '.price',
      '[data-price]',
      '.token-info .price',
      '.price-display'
    ];
    
    for (const selector of priceSelectors) {
      try {
        const element = await page.$(selector);
        if (element) {
          const priceText = await page.evaluate(el => el.textContent || el.innerText, element);
          console.log(`[${token}] نص من ${selector}: "${priceText}"`);
          const price = parseFloat(priceText.replace(/[^\d.eE\-+]/g, ''));
          if (!isNaN(price) && price > 0) {
            console.log(`[${token}] تم جلب السعر من ${selector}:`, price);
            return price;
          }
        }
      } catch (e) {
        // تجاهل وتابع مع السلكتور التالي
      }
    }
    
    // محاولة جلب السعر من عنوان الصفحة
    try {
      const title = await page.title();
      const titlePriceMatch = title.match(/\$([0-9]*\.?[0-9]+(?:[eE][-+]?[0-9]+)?)/);
      if (titlePriceMatch && titlePriceMatch[1]) {
        const priceValue = parseFloat(titlePriceMatch[1]);
        if (!isNaN(priceValue) && priceValue > 0.0000001 && priceValue < 100) {
          console.log(`[${token}] تم جلب السعر من العنوان: ${priceValue}`);
          return priceValue;
        }
      }
    } catch (e) {
      // تجاهل
    }
    
    // إذا لم تعمل السلكتورز، ابحث في النص بطريقة أكثر دقة
    try {
      const bodyText = await page.evaluate(() => document.body.innerText);
      
      // البحث عن أسعار في سياق واضح فقط مع معالجة الأرقام الصغيرة
      const contextualPricePatterns = [
        /price[:\s]*\$([0-9]*\.?[0-9]+(?:[eE][-+]?[0-9]+)?)/gi,
        /current[:\s]*\$([0-9]*\.?[0-9]+(?:[eE][-+]?[0-9]+)?)/gi,
        /\$([0-9]*\.?[0-9]+(?:[eE][-+]?[0-9]+)?)\s*USD/gi,
        /USD[:\s]*([0-9]*\.?[0-9]+(?:[eE][-+]?[0-9]+)?)/gi
      ];
      
      for (const pattern of contextualPricePatterns) {
        const matches = bodyText.matchAll(pattern);
        for (const match of matches) {
          const priceValue = parseFloat(match[1]);
          // فلتر إضافي: تجاهل الأرقام الكبيرة جداً أو الصغيرة جداً
          if (!isNaN(priceValue) && priceValue > 0 && priceValue < 1000000) {
            console.log(`[${token}] تم جلب السعر عبر pattern contextual: ${priceValue}`);
            return priceValue;
          }
        }
      }
      
      // البحث عن الأسعار الصغيرة جداً مع الرموز الخاصة مثل ₅ (subscript 5)
      const smallPricePatterns = [
        /\$0\.0₅([0-9]+)/g, // مثل $0.0₅30829
        /\$0\.0₄([0-9]+)/g, // مثل $0.0₄12345  
        /\$0\.0₃([0-9]+)/g, // مثل $0.0₃56789
        /\$0\.0₆([0-9]+)/g, // مثل $0.0₆98765
        /\$0\.0₇([0-9]+)/g, // مثل $0.0₇45678
        /\$0\.0₈([0-9]+)/g, // مثل $0.0₈12309
        /\$0\.0₉([0-9]+)/g  // مثل $0.0₉87654
      ];
      
      for (const pattern of smallPricePatterns) {
        const matches = bodyText.matchAll(pattern);
        for (const match of matches) {
          const digits = match[1];
          let priceValue;
          
          // تحديد عدد الأصفار بناءً على الرمز المستخدم
          if (pattern.source.includes('₅')) {
            priceValue = parseFloat(`0.00000${digits}`); // 5 أصفار
          } else if (pattern.source.includes('₄')) {
            priceValue = parseFloat(`0.0000${digits}`); // 4 أصفار
          } else if (pattern.source.includes('₃')) {
            priceValue = parseFloat(`0.000${digits}`); // 3 أصفار
          } else if (pattern.source.includes('₆')) {
            priceValue = parseFloat(`0.000000${digits}`); // 6 أصفار
          } else if (pattern.source.includes('₇')) {
            priceValue = parseFloat(`0.0000000${digits}`); // 7 أصفار
          } else if (pattern.source.includes('₈')) {
            priceValue = parseFloat(`0.00000000${digits}`); // 8 أصفار
          } else if (pattern.source.includes('₉')) {
            priceValue = parseFloat(`0.000000000${digits}`); // 9 أصفار
          }
          
          if (!isNaN(priceValue) && priceValue > 0) {
            console.log(`[${token}] تم جلب السعر الصغير: ${priceValue} من النص: ${match[0]}`);
            return priceValue;
          }
        }
      }
      
      // كحل أخير: ابحث عن أول سعر منطقي بشرط أن يكون في نطاق معقول
      const generalPricePattern = /\$([0-9]*\.?[0-9]+(?:[eE][-+]?[0-9]+)?)/g;
      const matches = bodyText.matchAll(generalPricePattern);
      for (const match of matches) {
        const priceValue = parseFloat(match[1]);
        // قبول الأسعار في نطاق معقول للعملات المشفرة الصغيرة
        if (!isNaN(priceValue) && priceValue > 0.0000001 && priceValue < 100) {
          console.log(`[${token}] تم جلب السعر عبر pattern عام: ${priceValue}`);
          return priceValue;
        }
      }
      
      // اطبع جزء من الصفحة للمساعدة في التصحيح
      console.log(`[${token}] لم يتم العثور على السعر، عنوان الصفحة: "${await page.title()}"`);
      console.log(`[${token}] جزء من الصفحة:\n`, bodyText.slice(0, 800));
      
      // محاولة العثور على أي نص يحتوي على علامة الدولار
      const dollarMatches = bodyText.match(/\$[0-9.,eE\-+]+/g);
      if (dollarMatches) {
        console.log(`[${token}] نصوص تحتوي على $:`, dollarMatches.slice(0, 10));
      }
    } catch (e) {
      console.log(`[${token}] خطأ أثناء قراءة نص الصفحة:`, e.message);
    }
    
    // إذا فشل Puppeteer، جرب طريقة API مباشرة
    console.log(`[${token}] فشل Puppeteer، محاولة استخدام API مباشر...`);
    try {
      const https = require('https');
      
      // محاولة استخدام API عام للحصول على بيانات التوكن
      const apiOptions = {
        hostname: 'api.dexscreener.com',
        port: 443,
        path: `/latest/dex/tokens/${token}`,
        method: 'GET',
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
          'Accept': 'application/json',
        }
      };
      
      const apiPrice = await new Promise((resolve, reject) => {
        const req = https.request(apiOptions, (res) => {
          let data = '';
          res.on('data', (chunk) => { data += chunk; });
          res.on('end', () => {
            try {
              const jsonData = JSON.parse(data);
              if (jsonData.pairs && jsonData.pairs.length > 0) {
                const price = parseFloat(jsonData.pairs[0].priceUsd);
                if (!isNaN(price) && price > 0) {
                  console.log(`[${token}] تم جلب السعر من API: ${price}`);
                  resolve(price);
                } else {
                  resolve(null);
                }
              } else {
                resolve(null);
              }
            } catch (parseError) {
              console.log(`[${token}] خطأ في تحليل JSON من API: ${parseError.message}`);
              resolve(null);
            }
          });
        });
        
        req.on('error', (error) => {
          console.log(`[${token}] خطأ في طلب API: ${error.message}`);
          resolve(null);
        });
        
        req.setTimeout(10000, () => {
          console.log(`[${token}] انتهت مهلة طلب API`);
          req.abort();
          resolve(null);
        });
        
        req.end();
      });
      
      if (apiPrice) {
        console.log(`[${token}] نجح في جلب السعر من API: ${apiPrice}`);
        return apiPrice;
      }
    } catch (apiError) {
      console.log(`[${token}] فشل في API request: ${apiError.message}`);
    }
    
    return null;
  }

  // كرر محاولة جلب السعر الأول حتى تحصل على قيمة صحيحة (فقط إذا لم يكن محفوظاً مسبقاً)
  let priceAttempts = 0;
  const maxPriceAttempts = 3; // تقليل المحاولات إلى 3
  
  // إذا كان لدينا أول سعر محفوظ مسبقاً، استخدمه
  if (firstPrice !== null) {
    console.log(`[${token}] استخدام أول سعر محفوظ مسبقاً: ${firstPrice}`);
  } else {
    // إذا لم يكن لدينا أول سعر محفوظ، اجلبه من الموقع
    while (firstPrice === null && priceAttempts < maxPriceAttempts) {
      try {
        console.log(`[${token}] محاولة ${priceAttempts + 1}/${maxPriceAttempts} لجلب السعر...`);
        firstPrice = await getPrice();
        if (firstPrice === null) {
          priceAttempts++;
          if (priceAttempts < maxPriceAttempts) {
            await new Promise(r => setTimeout(r, 5000)); // انتظر 5 ثوانٍ وأعد المحاولة
          }
        }
      } catch (error) {
        priceAttempts++;
        console.error(`[${token}] خطأ في محاولة ${priceAttempts}: ${error.message}`);
        await new Promise(r => setTimeout(r, 3000));
      }
    }
  }

  if (firstPrice === null) {
    console.error(`[${token}] فشل في جلب السعر بعد ${maxPriceAttempts} محاولات. إيقاف المراقبة.`);
    if (browser) await browser.close();
    trackedTokens[token].browserFailed = true;
    trackedTokens[token].firstPrice = "فشل في جلب السعر";
    trackedTokens[token].lastPrice = "غير متاح";
    saveTrackedTokens();
    return;
  }
  // تعيين lastPrice بناءً على الوضع الحالي
  if (trackedTokens[token] && trackedTokens[token].lastPrice && typeof trackedTokens[token].lastPrice === 'number') {
    lastPrice = trackedTokens[token].lastPrice;
  } else {
    lastPrice = firstPrice;
  }
  
  // تحديث البيانات في trackedTokens
  if (trackedTokens[token]) {
    // تحديث firstPrice فقط إذا لم يكن موجوداً من قبل
    if (!trackedTokens[token].firstPrice || typeof trackedTokens[token].firstPrice !== 'number') {
      trackedTokens[token].firstPrice = firstPrice;
    }
    // تحديث lastPrice فقط إذا لم يكن موجوداً من قبل أو كان أقل من القيمة الجديدة
    if (!trackedTokens[token].lastPrice || typeof trackedTokens[token].lastPrice !== 'number' || lastPrice > trackedTokens[token].lastPrice) {
      trackedTokens[token].lastPrice = lastPrice;
    }
    // حفظ الصفحة فقط وليس المتصفح (لأنه مشترك)
    trackedTokens[token].page = page;
    saveTrackedTokens();
  }

  // تحديث السعر كل 10 ثوانٍ
  (async function updateLoop() {
    while (trackedTokens[token] && !trackedTokens[token].stopped) {
      try {
        // التحقق من أن الصفحة ما زالت متصلة
        if (page.isClosed() || !browser.isConnected()) {
          console.log(`[${token}] الصفحة أو المتصفح مغلق، إيقاف المراقبة`);
          break;
        }
        
        const price = await getPrice();
        
        // تحقق من أن التوكن ما زال موجودًا ولم يُحذف أثناء الانتظار
        if (!trackedTokens[token]) break;
        
        if (price) {
          // تحديث lastPrice فقط إذا كان السعر الجديد أعلى من القيمة الحالية
          if (price > trackedTokens[token].lastPrice) {
            // New feature: Track price rise comparison
            const currentTime = new Date();
            const previousPrice = trackedTokens[token].lastPrice;
            
            // Check if this is a significant price increase (10% or more)
            const priceIncreasePercent = ((price - previousPrice) / previousPrice) * 100;
            
            if (priceIncreasePercent >= 10) {
              // Store the previous high price if not already set
              if (trackedTokens[token].previousHighPrice === null) {
                trackedTokens[token].previousHighPrice = previousPrice;
              }
              
              // Update current high price
              trackedTokens[token].currentHighPrice = price;
              
              // Calculate time difference from last rise
              let timeDifference = null;
              if (trackedTokens[token].lastRiseTime) {
                timeDifference = (currentTime - trackedTokens[token].lastRiseTime) / 1000 / 60; // in minutes
              }
              
              // Check if rise happened in less than 2 minutes
              if (timeDifference === null || timeDifference < 2) {
                trackedTokens[token].rapidRiseAchieved = true;
                // التأكد من وجود priceRiseHistory قبل الوصول إليه
                if (!trackedTokens[token].priceRiseHistory) {
                  trackedTokens[token].priceRiseHistory = [];
                }
                trackedTokens[token].priceRiseHistory.push({
                  fromPrice: previousPrice,
                  toPrice: price,
                  increasePercent: priceIncreasePercent,
                  timestamp: currentTime,
                  timeDifference: timeDifference,
                  isRapid: true
                });
              } else {
                // Add to history but mark as not rapid
                // التأكد من وجود priceRiseHistory قبل الوصول إليه
                if (!trackedTokens[token].priceRiseHistory) {
                  trackedTokens[token].priceRiseHistory = [];
                }
                trackedTokens[token].priceRiseHistory.push({
                  fromPrice: previousPrice,
                  toPrice: price,
                  increasePercent: priceIncreasePercent,
                  timestamp: currentTime,
                  timeDifference: timeDifference,
                  isRapid: false
                });
              }
              
              trackedTokens[token].lastRiseTime = currentTime;
            }
            
            trackedTokens[token].lastPrice = price;
          }
          // لا تغير firstPrice بعد تعيينه أول مرة
          const increase = ((price - trackedTokens[token].firstPrice) / trackedTokens[token].firstPrice) * 100;
          if (increase > trackedTokens[token].maxIncrease) trackedTokens[token].maxIncrease = increase;
          // إذا لم يصل بعد إلى 50% وحققها الآن، ثبّت reached50 على true
          if (!trackedTokens[token].reached50 && increase >= 50) {
            trackedTokens[token].reached50 = true;
          }
          
          // حفظ التحديثات كل دقيقة
          const now = Date.now();
          if (!trackedTokens[token].lastSave || now - trackedTokens[token].lastSave > 60000) {
            trackedTokens[token].lastSave = now;
            saveTrackedTokens();
          }
        }
      } catch (error) {
        console.error(`[${token}] خطأ في حلقة التحديث: ${error.message}`);
        // في حالة خطأ الاتصال، انتظر وقت أطول قبل إعادة المحاولة
        await new Promise(r => setTimeout(r, 30000)); // انتظار 30 ثانية
        continue;
      }
      
      await new Promise(r => setTimeout(r, 10000));
    }
    // إغلاق الصفحة فقط وليس المتصفح المشترك
    if (page && !page.isClosed()) {
      await page.close().catch(err => {
        console.log(`[${token}] خطأ في إغلاق الصفحة: ${err.message}`);
      });
    }
  })();
}

// Helper function to check rapid rise conditions
function checkRapidRiseCondition(token, currentPrice, previousPrice, currentTime) {
  if (!trackedTokens[token]) return false;
  
  const priceIncreasePercent = ((currentPrice - previousPrice) / previousPrice) * 100;
  
  // Check if price increased by 10% or more
  if (priceIncreasePercent >= 10) {
    const timeDifference = trackedTokens[token].lastRiseTime 
      ? (currentTime - trackedTokens[token].lastRiseTime) / 1000 / 60 // in minutes
      : null;
    
    // If rise happened in less than 2 minutes, it's considered rapid
    if (timeDifference === null || timeDifference < 2) {
      return true;
    }
  }
  
  return false;
}

// مراقبة يدوية بدون puppeteer (استخدام HTTP requests)
function startManualTracking(token) {
  if (!trackedTokens[token]) return;
  
  trackedTokens[token].manualMode = true;
  trackedTokens[token].firstPrice = "وضع يدوي - غير متاح";
  trackedTokens[token].lastPrice = "يتطلب Chrome";
  trackedTokens[token].rugcheckStatus = null; // لم يتم التحقق في الوضع اليدوي
  // Initialize new properties for manual mode
  trackedTokens[token].previousHighPrice = null;
  trackedTokens[token].currentHighPrice = null;
  trackedTokens[token].lastRiseTime = null;
  trackedTokens[token].rapidRiseAchieved = false;
  trackedTokens[token].priceRiseHistory = [];
  
  // حفظ التحديثات
  saveTrackedTokens();
  
  console.log(`[${token}] بدء المراقبة في الوضع اليدوي (بدون Puppeteer)`);
  console.log(`[${token}] لتفعيل المراقبة الكاملة، قم بتثبيت Chrome: npx puppeteer browsers install chrome`);
}

// حذف التوكن من المراقبة
function stopTrackingToken(token) {
  if (trackedTokens[token]) {
    trackedTokens[token].stopped = true;
    // إغلاق الصفحة إذا كانت مفتوحة (وليس المتصفح المشترك)
    if (trackedTokens[token].page) {
      trackedTokens[token].page.close().catch(err => {
        console.error(`[${token}] خطأ في إغلاق الصفحة: ${err.message}`);
      });
    }
    delete trackedTokens[token];
    // حفظ التغييرات
    saveTrackedTokens();
    console.log(`🗑️ تم حذف التوكن ${token} من المراقبة`);
  }
}

// بيانات الدخول تلقائية للسيرفر
const PHONE_NUMBER = "+967xxxxxxxxx";  // ضع رقمك هنا
const PASSWORD = "YOUR_PASSWORD"; // إذا كان لديك كلمة مرور 2FA
const PHONE_CODE = undefined; // يمكن تركه undefined ليتم تجاهله

const apiId = 23299626;
const apiHash = "89de50a19288ec535e8b008ae2ff268d";

console.log("🚀 البوت يعمل الآن 24 ساعة على السيرفر!");

// تنظيف العمليات المعلقة من Chrome عند بدء البرنامج
function cleanupChromeProcesses() {
  try {
    const { exec } = require('child_process');
    // إنهاء عمليات Chrome المعلقة على Windows
    exec('taskkill /f /im chrome.exe /t', (error, stdout, stderr) => {
      if (!error) {
        console.log('🧹 تم تنظيف عمليات Chrome المعلقة');
      }
    });
  } catch (error) {
    // تجاهل الأخطاء
  }
}

// تنظيف العمليات المعلقة عند بدء البرنامج
cleanupChromeProcesses();

// إنشاء المتصفح المشترك عند بدء البرنامج
async function initializeSharedBrowser() {
  try {
    await getSharedBrowser();
    console.log('✅ تم تجهيز المتصفح المشترك بنجاح');
  } catch (error) {
    console.error('⚠️ فشل في تجهيز المتصفح المشترك:', error.message);
    console.log('📱 سيتم التشغيل في الوضع اليدوي فقط');
  }
}

// تجهيز المتصفح وتحميل التوكنات
initializeSharedBrowser().then(() => {
  // تحميل التوكنات المحفوظة بعد تجهيز المتصفح
  loadTrackedTokens();
  // تحميل التوكنات المرسلة
  loadSentTokens();
}).catch(err => {
  console.error('خطأ في التهيئة:', err.message);
  // تحميل التوكنات حتى لو فشل المتصفح
  loadTrackedTokens();
  // تحميل التوكنات المرسلة
  loadSentTokens();
});

// دالة لتسجيل الدخول والخروج
function logLoginLogout(type) {
  const logFile = 'login_logout_log.txt';
  const now = new Date().toISOString();
  fs.appendFileSync(logFile, `${type},${now}\n`, 'utf8');
}

// تسجيل الدخول
logLoginLogout('login');

// نحاول تحميل الجلسة من ملف
let stringSession = new StringSession("");

if (fs.existsSync("session.txt")) {
  const savedSession = fs.readFileSync("session.txt", "utf8");
  stringSession = new StringSession(savedSession.trim());
}

(async () => {
  console.log("📲 بدء الاتصال بتليجرام...");
  const client = new TelegramClient(stringSession, apiId, apiHash, {
    connectionRetries: 5,
  });

  // تسجيل الدخول عند الحاجة فقط
  try {
    await client.start({
      phoneNumber: async () => PHONE_NUMBER,
      password: async () => PASSWORD,
      phoneCode: async () => PHONE_CODE,
      onError: (err) => console.log("❌ خطأ:", err),
    });
  } catch (err) {
    if (err.errorMessage === 'AUTH_KEY_DUPLICATED') {
      console.error('❌ AUTH_KEY_DUPLICATED: سيتم حذف الجلسة القديمة وإنشاء جلسة جديدة.');
      fs.unlinkSync('session.txt'); // حذف ملف الجلسة القديمة
      stringSession = new StringSession(""); // إعادة تعيين الجلسة
      await client.start({
        phoneNumber: async () => PHONE_NUMBER,
        password: async () => PASSWORD,
        phoneCode: async () => PHONE_CODE,
        onError: (err) => console.log("❌ خطأ:", err),
      });
    } else {
      throw err; // إعادة رمي الخطأ إذا لم يكن AUTH_KEY_DUPLICATED
    }
  }

  console.log("✅ تم تسجيل الدخول!");
  const sessionString = client.session.save();

  // حفظ الجلسة للاستخدام التالي
  fs.writeFileSync("session.txt", sessionString);
  console.log("💾 تم حفظ الجلسة في session.txt");

  await client.sendMessage("me", { message: "🚀 بوت الإشعارات شغال!" });

  // تحقق من الانضمام للبوتات المطلوبة مرة واحدة فقط في الحياة
  const joinedBotsFile = 'joined_bots.txt';
  if (!fs.existsSync(joinedBotsFile)) {
    try {
      // قائمة البوتات المطلوبة
      const botsToJoin = ['GMGN_sol_bot', 'solBigamout'];
      for (const bot of botsToJoin) {
        // أرسل فقط للبوتات التي تنتهي بـ _bot
        if (bot.endsWith('_bot')) {
          await client.sendMessage(bot, { message: '/start' });
          await sleep(2000);
        } else {
          console.log(`⚠️ تخطي ${bot}: ليس بوت تليجرام.`);
        }
      }
      fs.writeFileSync(joinedBotsFile, 'done');
      console.log('✅ تم الانضمام لكل البوتات المطلوبة لأول مرة.');
    } catch (err) {
      console.error('❌ خطأ أثناء الانضمام للبوتات:', err.message);
    }
  }

  // التتبع والتوجيه
  client.addEventHandler(async (update) => {
    try {
      // تعديل شروط الفلترة لإضافة الفرز الرابع
      if (update.message && typeof update.message.message === "string") {

        const msg = update.message;
        const text = msg.message;

        // ميزة منفصلة: عند استقبال FARESS أرسل صفحة تتبع التوكن كملف HTML إلى GMGN
        if (text.trim() === "FARESS") {
          const { fetchAndSaveTrackTokenPage } = require("./sendTrackTokenPage");
          const htmlFile = await fetchAndSaveTrackTokenPage();
          if (htmlFile) {
            try {
              await client.sendFile('GMGN_sol_bot', {
                file: htmlFile,
                caption: '📊 صفحة تتبع التوكن الحالية (طلب FARESS)'
              });
              console.log('✅ تم إرسال صفحة تتبع التوكن كملف HTML إلى GMGN_sol_bot');
            } catch (err) {
              console.error('❌ فشل في إرسال الملف إلى GMGN_sol_bot:', err.message);
            }
          } else {
            console.error('❌ تعذر جلب أو حفظ صفحة تتبع التوكن');
          }
          return;
        }

        // فلترة الرسائل التي تحتوي على "counts: 1" أو أكثر و"25 SOL" أو أكثر
    // تعديل شرط الفرز ليكون من "SOL 10.00" وأعلى
    if (/\bcounts:\s*(\d+)\b/i.test(text) && parseInt(text.match(/\bcounts:\s*(\d+)\b/i)[1]) >= 1 &&
      /(1[0-9]|[2-9]\d|\d{3,})\.\d{2}\s*SOL(\D|$)/.test(text)) {

          // استخراج قيمة SOL من النص
          const solMatch = text.match(/([\d,]+\.\d{2})\s*SOL/);
          let solValue = null;
          if (solMatch && solMatch[1]) {
            solValue = parseFloat(solMatch[1].replace(/,/g, ''));
            console.log(`💰 قيمة SOL المستخرجة: ${solValue}`);
          }

          // فلترة "5m" بحيث تكون بين 0% و 3000%
          const fiveMinMatch = text.match(/5m\s*\((\d+\.\d+)%\)/);
          if (fiveMinMatch) {
            const fiveMinPercentage = parseFloat(fiveMinMatch[1]);
            if (fiveMinPercentage > 3000) {
              console.log(`⚠️ النسبة 5m (${fiveMinPercentage}%) أكبر من 3000%. تخطي.`);
              return;
            }
          }

          // الشرط الرابع: التحقق من أن عدد الأيام (d) يساوي 0
          const ageMatch = text.match(/age:\s*(\d+)d\s*(\d+)h/);
          if (ageMatch) {
            const days = parseInt(ageMatch[1]);
            if (days !== 0) {
              console.log(`⚠️ عدد الأيام (d) ليس 0. تخطي.`);
              return;
            }
          }

          // فلترة السعر price: $... يجب أن يكون أقل من 0.01
          const priceMatch = text.match(/price:\s*\$?([\deE\.-]+)/i);
          if (priceMatch && priceMatch[1]) {
            let priceValue = parseFloat(priceMatch[1]);
            if (isNaN(priceValue)) {
              // محاولة التحويل من صيغة علمية
              try {
                priceValue = Number(priceMatch[1]);
              } catch {}
            }
            if (!(priceValue < 0.01)) {
              console.log(`⚠️ السعر ${priceValue} أكبر أو يساوي 0.01. تخطي.`);
              return;
            }
          } else {
            // إذا لم يوجد سعر، تخطى
            console.log('⚠️ لم يتم العثور على السعر في الرسالة. تخطي.');
            return;
          }

          const startTime = performance.now();
          // استخراج التوكن بعد ca:
          const caMatch = text.match(/ca:\s*([\w]+)/);
          if (caMatch && caMatch[1]) {
            const token = caMatch[1];
            if (sentTokens.has(token)) {
              console.log(`⚠️ التوكن ${token} تم إرساله مسبقًا. تخطي.`);
              return;
            }
            
            // طباعة التوكن مع قيمة SOL
            console.log(`${token} (${solValue ? solValue.toFixed(2) + ' SOL' : 'SOL غير محدد'})`);
            
            // التحقق من حالة التوكن على rugcheck.xyz قبل الإرسال
            console.log(`[${token}] 🔍 بدء التحقق من حالة التوكن على rugcheck.xyz...`);
            const tokenSafety = await checkTokenSafety(token);
            
            // حفظ حالة rugcheck في بيانات التوكن للعرض لاحقاً
            if (trackedTokens[token]) {
              trackedTokens[token].rugcheckStatus = tokenSafety;
            }
            
            if (tokenSafety === 'DANGER') {
              console.log(`[${token}] ❌ تم رفض التوكن - مصنف كـ DANGER على rugcheck.xyz`);
              console.log(`[${token}] 🚫 لن يتم إرسال أمر الشراء أو إرسال التوكن إلى GMGN`);
              
              // بدء مراقبة التوكن حتى لو تم رفضه (لأغراض الإحصائيات)
              startTrackingToken(token, tokenSafety, solValue).catch(err => {
                console.error(`[${token}] خطأ في بدء المراقبة: ${err.message}`);
              });
              
              return; // عدم إرسال التوكن إذا كان خطر
            } else if (tokenSafety === 'WARNING') {
              console.log(`[${token}] ⚠️ تحذير - التوكن مصنف كـ WARNING على rugcheck.xyz`);
              console.log(`[${token}] 🤔 لن يتم إرسال أمر الشراء كإجراء احترازي`);
              
              // بدء مراقبة التوكن حتى لو تم رفضه (لأغراض الإحصائيات)
              startTrackingToken(token, tokenSafety, solValue).catch(err => {
                console.error(`[${token}] خطأ في بدء المراقبة: ${err.message}`);
              });
              
              return; // عدم إرسال التوكن إذا كان تحذير
            } else if (tokenSafety === 'GOOD') {
              console.log(`[${token}] ✅ التوكن آمن - مصنف كـ GOOD على rugcheck.xyz`);
              console.log(`[${token}] 🚀 سيتم المتابعة مع إرسال أمر الشراء والتوكن إلى GMGN`);
            } else {
              console.log(`[${token}] ⚠️ لم يتم تحديد حالة التوكن على rugcheck.xyz (ربما خطأ في التحقق)`);
              console.log(`[${token}] 🤔 سيتم المتابعة مع الحذر...`);
            }
            
            // حفظ التوكن في ملف لاستخدامه في بوت sniperoo
            fs.writeFileSync('last_token.txt', token, 'utf8');

            // إرسال أمر الشراء والتوكن فقط إذا كان التوكن آمن (GOOD)
            if (tokenSafety === 'GOOD') {
              // إرسال أمر الشراء والتوكن في نفس اللحظة (زمن بلانك)
              const buyMsg = `/buy ${token} ${buyPrice}`;
              client.sendMessage(botUsername, { message: buyMsg });
              client.sendMessage(botUsername, { message: token });
              console.log('✅ تم إرسال أمر الشراء المباشر:', buyMsg);
              console.log('📩 تم إرسال التكوين لمعرفة السعر بعد الشراء.');

              // إضافة التوكن إلى القائمة المرسلة
              sentTokens.add(token);
              fs.appendFileSync(sentTokensFile, `${token}\n`, 'utf8');

              // بدء مراقبة التوكن (مع معالجة الأخطاء)
              startTrackingToken(token, tokenSafety, solValue).catch(err => {
                console.error(`[${token}] خطأ في بدء المراقبة: ${err.message}`);
              });
            } else {
              console.log(`[${token}] 🛑 تم تخطي إرسال أمر الشراء والتوكن بسبب أن حالة rugcheck ليست آمنة (الحالة: ${tokenSafety})`);
              // بدء مراقبة التوكن حتى لو لم يكن آمنًا (لأغراض الإحصائيات) مع تمرير الحالة
              startTrackingToken(token, tokenSafety, solValue).catch(err => {
                console.error(`[${token}] خطأ في بدء المراقبة: ${err.message}`);
              });
            }

            const endTime = performance.now();
            const executionTimeLog = `⏱️ وقت التنفيذ للتوكن ${token}: ${(endTime - startTime).toFixed(2)} مللي ثانية.`;
            console.log(executionTimeLog);
            executionLogsBuffer.push(`${executionTimeLog}\n`);
          }
        }
      }
    } catch (err) {
      console.error("❌ خطأ أثناء التوجيه:", err.message);
    }
  });
})();

const botUsername = 'GMGN_sol_bot';

// دالة التداول التلقائي في بوت GMGN
async function tradeInGMGNBot(client, token) {
  const lastStartFile = 'gmgn_last_start.txt';
  let shouldSendStart = true;
  try {
    // تحقق من آخر إرسال لـ /start
    if (fs.existsSync(lastStartFile)) {
      const lastStartDate = fs.readFileSync(lastStartFile, 'utf8').trim();
      const today = new Date().toISOString().slice(0, 10);
      if (lastStartDate === today) {
        shouldSendStart = false;
      }
    }
    // إرسال /start مرة واحدة فقط يومياً
    if (shouldSendStart) {
      await client.sendMessage(botUsername, { message: '/start' });
      fs.writeFileSync(lastStartFile, new Date().toISOString().slice(0, 10));
      await sleep(2000);
    }
    // إرسال التوكن
    await client.sendMessage(botUsername, { message: token });
    await sleep(3000);

    // استقبال رسائل البوت وطباعة كل رسالة والبحث عن السعر
    let price = null;
    let done = false;
    let lastBotMessage = null;
    const handler = async (update) => {
      // تحقق من أن الرسالة من بوت GMGN بناءً على اسم المستخدم أو peerId
      if (update.message && update.message.peerId && (
            (update.message.peerId.userId && update.message.peerId.userId.toString().includes('GMGN')) ||
            (update.message.peerId.channelId && botUsername.includes('GMGN'))
          )) {
        const text = update.message.message;
        lastBotMessage = text;
        // تحقق أن الرسالة تحتوي على التوكن المطلوب
        if (text.includes(token)) {
          // استخراج السعر من الرسالة
          let priceMatch = text.match(/price:\s*\$?([\d\.]+)/i);
          if (priceMatch && priceMatch[1]) {
            price = parseFloat(priceMatch[1]);
            done = true;
            // طباعة السعر فقط بدون باقي الرسالة وبدون علامة الدولار
            console.log('📩 السعر من GMGN: ' + priceMatch[1]);
            // حساب السعر الجديد بزيادة 1000%
            const newPrice = (price * 10).toFixed(6);
            // إرسال أمر التداول مباشرة
            const orderMsg = `/create limitbuy ${token} 0.5@${newPrice} -exp 86400`;
            await client.sendMessage(botUsername, { message: orderMsg });
            console.log('✅ تم إرسال أمر التداول:', orderMsg);
          } else {
            // إذا لم يوجد سعر، اطبع الرسالة كاملة
            console.log('📩 رسالة من GMGN:\n' + text);
          }
        }
      }
    };
    client.addEventHandler(handler);
    // انتظر حتى يتم استقبال السعر أو انتهاء المهلة
    let tries = 0;
    while (!done && tries < 10) {
      await sleep(1000);
      tries++;
    }
    client.removeEventHandler(handler);
    if (!price) {
      console.log('📩 رد البوت بعد ارسال التوكن:\n' + (lastBotMessage || 'لم يتم استقبال أي رسالة من البوت بعد إرسال التوكن'));
      return;
    }
    // حساب السعر الجديد بزيادة 1000%
    const newPrice = (price * 10).toFixed(6);
    // إرسال أمر التداول
    const orderMsg = `/create limitbuy ${token} 0.5@${newPrice} -exp 86400`;
    await client.sendMessage(botUsername, { message: orderMsg });
    console.log('✅ تم إرسال أمر التداول:', orderMsg);
  } catch (err) {
    console.error('❌ خطأ في التداول مع GMGN:', err.message);
  }
}

// دالة تأخير بسيطة
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

let buyPrice = 0.5; // السعر الافتراضي

const PORT = process.env.PORT || 1010;
const server = http.createServer((req, res) => {
  // Health check endpoint للتوافق مع Render
  if (req.method === "GET" && req.url === "/health") {
    res.writeHead(200, { "Content-Type": "application/json" });
    res.end(JSON.stringify({ status: "OK", timestamp: new Date().toISOString() }));
    return;
  }

  // Root endpoint للتحقق من حالة البوت
  if (req.method === "GET" && req.url === "/") {
    res.writeHead(200, { "Content-Type": "text/html; charset=utf-8" });
    res.end(`
      <div style='text-align:center; font-family: Arial, sans-serif; padding: 50px;'>
        <h1 style='color: #0078D7;'>🚀 البوت يعمل بنجاح!</h1>
        <p style='font-size: 1.2em; color: #333;'>الوقت الحالي: ${new Date().toLocaleString('ar-SA')}</p>
        <p><a href="/track_token" style='color: #0078D7; text-decoration: none;'>📊 متابعة التوكنات</a></p>
      </div>
    `);
    return;
  }

  if (req.method === "POST" && req.url === "/delete-all") {
    // مسح محتويات ملف السجلات
    fs.writeFileSync('execution_logs.txt', '', 'utf8');
    res.writeHead(200, { "Content-Type": "text/html; charset=utf-8" });
    res.end(`
      <div style='text-align:center;'>
        <div style='font-size:2em;'>🚀 تم مسح جميع السجلات بنجاح!</div>
        <a href="/" style='font-size:1.5em; color:#0078D7;'>العودة إلى الصفحة الرئيسية</a>
      </div>
    `);
    return;
  }

  if (req.method === "POST" && req.url === "/update-price") {
    let body = "";
    req.on("data", chunk => {
      body += chunk.toString();
    });
    req.on("end", () => {
      const params = new URLSearchParams(body);
      const newPrice = parseFloat(params.get("price"));
      if (!isNaN(newPrice) && newPrice > 0) {
        buyPrice = newPrice;
        res.writeHead(200, { "Content-Type": "text/html; charset=utf-8" });
        res.end(`
          <div style='text-align:center;'>
            <div style='font-size:2em;'>✅ تم تحديث السعر بنجاح إلى: ${buyPrice}</div>
            <a href="/" style='font-size:1.5em; color:#0078D7;'>العودة إلى الصفحة الرئيسية</a>
          </div>
        `);
      } else {
        res.writeHead(400, { "Content-Type": "text/html; charset=utf-8" });
        res.end(`
          <div style='text-align:center;'>
            <div style='font-size:2em; color:red;'>❌ السعر المدخل غير صالح!</div>
            <a href="/" style='font-size:1.5em; color:#0078D7;'>العودة إلى الصفحة الرئيسية</a>
          </div>
        `);
      }
    });
    return;
  }

  // ...existing code...
  if (req.method === "GET" && req.url.startsWith("/track_token")) {
    res.writeHead(200, { "Content-Type": "text/html; charset=utf-8" });
    res.end(`
      <html lang="ar">
      <head>
        <title>Token Tracker</title>
        <meta http-equiv="refresh" content="10">
        <style>
          body { font-family: Tahoma, Arial, sans-serif; background: #f5f6fa; margin: 0; padding: 20px; direction: rtl; }
          h2 { text-align: center; color: #0078D7; margin-top: 30px; letter-spacing: 1px; text-shadow: 1px 1px 2px rgba(0,0,0,0.1); }
          .tokens-container { max-width: 800px; margin: 30px auto; padding: 0 10px; }
          .token-card {
            background: linear-gradient(145deg, #ffffff, #f8f9fa);
            border: 2px solid #e1e8ed;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1), 0 2px 4px rgba(0,0,0,0.06);
            padding: 20px 25px;
            margin-bottom: 25px;
            border-radius: 15px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
          }
          .token-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #0078D7, #1890ff, #52c41a);
            opacity: 0.8;
          }
          .token-card:hover { 
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15), 0 4px 8px rgba(0,0,0,0.1);
            border-color: #0078D7;
          }
          .token-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #f0f0f0;
          }
          .token-title {
            font-size: 1.2em;
            font-weight: bold;
            color: #2c3e50;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
          }
          .token-label { 
            color: #34495e; 
            font-weight: 600; 
            display: inline-block; 
            min-width: 170px;
            font-size: 0.95em;
          }
          .token-value { color: #0078D7; font-weight: bold; }
          .token-row { 
            margin-bottom: 8px;
            padding: 5px 0;
            border-bottom: 1px dotted #e8e8e8;
          }
          .token-row:last-child {
            border-bottom: none;
          }
          .delete-btn {
            background: linear-gradient(145deg, #e53935, #d32f2f);
            color: #fff;
            border: none;
            border-radius: 8px;
            padding: 8px 16px;
            font-size: 0.9em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
          }
          .delete-btn:hover { 
            background: linear-gradient(145deg, #d32f2f, #b71c1c);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
          }
        </style>
      </head>
      <body>
        <h2>متابعة التوكنات (Token Tracker)</h2>
        <div style='text-align: center; margin-bottom: 20px; color: #666; font-size: 0.9em;'>
          🔄 التوكنات محفوظة تلقائياً وتستمر المراقبة حتى بعد إعادة تشغيل البرنامج<br/>
          🛡️ يتم التحقق من كل توكن على rugcheck.xyz: <span style="color: #4CAF50;">✅ آمن</span> | <span style="color: #FF9800;">🔶 تحذير</span> | <span style="color: #F44336;">⚠️ خطر</span> | <span style="color: #666;">❓ غير محقق</span><br/>
          💧 يتم فحص السيولة من gmgn.ai: <span style="color: #4CAF50;">✅ سيولة طبيعية</span> | <span style="color: #FF5722;">⚠️ سيولة منخفضة</span> | <span style="color: #666;">❓ غير محققة</span><br/>
          � قيمة SOL المستخرجة من رسالة الفرز الأصلية (الحد الأدنى: 10.00 SOL)<br/>
          �🚫 <strong>المراقبة تتوقف تلقائياً عند اكتشاف سيولة منخفضة</strong>
        </div>
        <div class="tokens-container">
        ${Object.values(trackedTokens)
          .sort((a, b) => b.startTime - a.startTime) // الأحدث أولاً
          .map(t => {
            let percent = '';
            let firstPriceDisplay = '';
            let lastPriceDisplay = '';
            let priceComparison = '';
            
            if (t.browserFailed) {
              firstPriceDisplay = '⚠️ فشل في تحميل المتصفح';
              lastPriceDisplay = '❌ غير متاح';
              percent = 'غير متاح';
              priceComparison = 'غير متاح';
            } else if (t.firstPrice && t.lastPrice && typeof t.firstPrice === 'number' && typeof t.lastPrice === 'number') {
              const p = ((t.lastPrice - t.firstPrice) / t.firstPrice) * 100;
              percent = (p >= 0 ? '+' : '') + p.toFixed(2) + '%';
              firstPriceDisplay = t.firstPrice + '$';
              lastPriceDisplay = t.lastPrice + '$';
              
              // مقارنة النسبة بين أعلى سعر والسعر الأول
              const ratio = (t.lastPrice / t.firstPrice).toFixed(2);
              if (ratio >= 10) {
                priceComparison = `🚀 ارتفع ${ratio}x من السعر الأول`;
              } else if (ratio >= 5) {
                priceComparison = `📈 ارتفع ${ratio}x من السعر الأول`;
              } else if (ratio >= 2) {
                priceComparison = `⬆️ ارتفع ${ratio}x من السعر الأول`;
              } else if (ratio > 1) {
                priceComparison = `🔼 ارتفع ${ratio}x من السعر الأول`;
              } else if (ratio == 1) {
                priceComparison = `➡️ لا تغيير في السعر`;
              } else {
                priceComparison = `🔻 انخفض إلى ${ratio}x من السعر الأول`;
              }
            } else if (t.firstPrice && typeof t.firstPrice === 'string') {
              firstPriceDisplay = t.firstPrice;
              lastPriceDisplay = t.lastPrice || 'جاري التحميل...';
              percent = 'غير متاح';
              priceComparison = 'غير متاح';
            } else {
              firstPriceDisplay = 'جاري التحميل...';
              lastPriceDisplay = 'جاري التحميل...';
              percent = '...';
              priceComparison = '...';
            }
            
            // حساب مدة المراقبة hh:mm:ss
            let duration = '...';
            if (t.startTime) {
              const ms = Date.now() - t.startTime.getTime();
              const totalSeconds = Math.floor(ms / 1000);
              const hours = Math.floor(totalSeconds / 3600);
              const minutes = Math.floor((totalSeconds % 3600) / 60);
              const seconds = totalSeconds % 60;
              duration = `${hours.toString().padStart(2,'0')}:${minutes.toString().padStart(2,'0')}:${seconds.toString().padStart(2,'0')}`;
            }
            
            const statusIcon = t.browserFailed ? '⚠️' : t.stopped && t.lowLiquidity ? '🚫' : (t.reached50 ? '✅️' : '🔶');
            
            return `
              <div class="token-card" data-token="${t.token}">
                <div class="token-header">
                  <span class="token-title">${statusIcon} ${t.token}</span>
                  <button class="delete-btn" onclick="deleteToken('${t.token}')">حذف</button>
                </div>
                <div class="token-row"><span class="token-label">🛡️ حالة rugcheck.xyz:</span> <span style="color: ${t.rugcheckStatus === 'GOOD' ? '#4CAF50' : t.rugcheckStatus === 'DANGER' ? '#F44336' : t.rugcheckStatus === 'WARNING' ? '#FF9800' : '#666'}; font-weight: bold;">${t.rugcheckStatus === 'GOOD' ? '✅ آمن' : t.rugcheckStatus === 'DANGER' ? '⚠️ خطر' : t.rugcheckStatus === 'WARNING' ? '🔶 تحذير' : '❓ لم يتم التحقق'}</span></div>
                <div class="token-row"><span class="token-label">💧 السيولة:</span> <span style="color: ${t.lowLiquidity === true ? '#FF5722' : t.lowLiquidity === false ? '#4CAF50' : '#666'}; font-weight: bold;">${t.lowLiquidity === true ? '⚠️ منخفضة' : t.lowLiquidity === false ? '✅ طبيعية' : '❓ غير محققة'}</span></div>
                <div class="token-row"><span class="token-label">� قيمة SOL:</span> <span style="color: #FF9800; font-weight: bold;">${t.solValue ? t.solValue.toFixed(2) + ' SOL' : '❓ غير محددة'}</span></div>
                <div class="token-row"><span class="token-label">�🕐 مدة المراقبة:</span> ${duration}</div>
                <div class="token-row"><span class="token-label">💰 السعر الأول:</span> ${firstPriceDisplay}</div>
                <div class="token-row"><span class="token-label">💰 السعر الحالي:</span> ${lastPriceDisplay}</div>
                <div class="token-row"><span class="token-label">📊 التغيير:</span> ${percent}</div>
                <div class="token-row"><span class="token-label">📈 المقارنة:</span> ${priceComparison}</div>
                <div class="token-row"><span class="token-label">🎯 حقق 50%:</span> ${t.reached50 ? '✅ نعم' : '❌ لا'}</div>
                <div class="token-row"><span class="token-label">⏰ بدء المراقبة:</span> ${t.startTime ? t.startTime.toLocaleString('ar-EG') : 'غير محدد'}</div>
                ${t.stopped ? '<div class="token-row"><span class="token-label">🛑 السبب:</span> ' + (t.lowLiquidity ? 'توقفت بسبب السيولة المنخفضة' : 'توقفت لسبب غير معروف') + '</div>' : ''}
              </div>
            `;
          }).join('')}
        </div>
        
        <script>
          function deleteToken(token) {
            if (confirm('هل أنت متأكد من حذف هذا التوكن؟')) {
              fetch('/delete-token', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ token })
              })
              .then(response => response.json())
              .then(data => {
                if (data.success) {
                  location.reload();
                } else {
                  alert('فشل في الحذف: ' + data.error);
                }
              })
              .catch(err => alert('خطأ: ' + err.message));
            }
          }
          
          // تحديث الصفحة كل 10 ثوانِ
          setTimeout(() => location.reload(), 10000);
        </script>
      </body>
    </html>
    `);
    return;
  }
});

server.listen(PORT, () => {
  console.log(`🌐 الخادم يعمل على المنفذ ${PORT}`);
  console.log(`🔗 رابط متابعة التوكنات: http://localhost:${PORT}/track_token`);
});
